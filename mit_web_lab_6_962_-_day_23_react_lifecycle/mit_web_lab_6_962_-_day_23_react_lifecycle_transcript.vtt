WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 27ff2253-aff5-4bd6-82b8-66d6556400ab
Created: 2025-05-15T20:17:48.988Z
Duration: 4924.369
Channels: 1

00:00:00.880 --> 00:00:05.120
Okay. I'm gonna get started. This is a

00:00:05.120 --> 00:00:07.760
pretty intense lecture. There's gonna be quite a

00:00:07.760 --> 00:00:09.520
few important things that you'll learn that you'll

00:00:09.520 --> 00:00:11.760
see pretty much throughout the next two weeks.

00:00:12.160 --> 00:00:15.535
So hopefully you stick along with me. Essentially,

00:00:15.535 --> 00:00:17.455
this lecture is going to be about the

00:00:17.455 --> 00:00:22.175
React lifecycle. So how components are created, how

00:00:22.175 --> 00:00:25.935
they're updated, and then how they're dismounted, as

00:00:25.935 --> 00:00:28.440
well as hooks. And I'll get more into

00:00:28.440 --> 00:00:32.840
hooks. Well, you've actually seen one before. But,

00:00:33.720 --> 00:00:36.840
yeah. So just as a quick review, when

00:00:36.840 --> 00:00:39.400
you're working with a component tree, there's three

00:00:39.400 --> 00:00:41.240
main motivations for when you want to break

00:00:41.240 --> 00:00:45.005
it down into smaller components or break a

00:00:45.005 --> 00:00:49.085
component into smaller components. So the first is

00:00:49.085 --> 00:00:51.485
if it's getting too long, too hard to

00:00:51.485 --> 00:00:53.405
read. The code that you saw in the

00:00:53.405 --> 00:00:55.820
previous workshop could all theoretically be in the

00:00:55.820 --> 00:00:59.180
same component, but that's just not ideal. When

00:00:59.180 --> 00:01:00.780
you're working on a large code base, you

00:01:00.780 --> 00:01:02.940
want everything to have its own purpose. So

00:01:02.940 --> 00:01:07.580
you want to split up large files into

00:01:07.580 --> 00:01:10.365
smaller ones that you can work on files

00:01:10.365 --> 00:01:12.925
one at a time and track your changes

00:01:12.925 --> 00:01:17.005
better. And an analogy is when you're building

00:01:17.005 --> 00:01:19.005
a house, have specific plans for each of

00:01:19.005 --> 00:01:22.830
the rooms that you're building. And in React,

00:01:22.830 --> 00:01:25.630
in the previous workshop, you don't want to

00:01:25.630 --> 00:01:27.870
add the nav bar to your app component

00:01:27.870 --> 00:01:33.310
because it serves a different purpose. The second

00:01:33.310 --> 00:01:35.950
reason I mean, all these reasons are pretty

00:01:35.425 --> 00:01:38.945
related, but the second reason is that these

00:01:38.945 --> 00:01:43.585
parts or sections have different functionalities. So like

00:01:43.585 --> 00:01:47.505
in a shopping mall, different stores have their

00:01:47.665 --> 00:01:51.930
different purposes. So you don't want all the

00:01:51.930 --> 00:01:53.450
source to be in the same component. You

00:01:53.450 --> 00:01:57.690
want a store component so that you can

00:01:57.690 --> 00:02:03.130
treat each of them differently. And in React,

00:02:03.290 --> 00:02:06.330
comments, even though they could be stored inside

00:02:06.330 --> 00:02:09.035
of a post component, should reside in their

00:02:09.035 --> 00:02:14.315
own component because it's more reusable and comments

00:02:14.315 --> 00:02:19.275
have their own functionality. And the third is

00:02:19.275 --> 00:02:21.915
if your components like handling too many responsibilities,

00:02:23.480 --> 00:02:26.040
To make your code more readable, you want

00:02:26.600 --> 00:02:29.320
each component to do its own thing. So

00:02:29.320 --> 00:02:32.120
again, it's easier to track your changes. So

00:02:32.120 --> 00:02:35.400
in React, if your button does a lot

00:02:35.400 --> 00:02:38.715
of back end things, like sends or sends

00:02:38.715 --> 00:02:41.355
something to your server or it has a

00:02:41.355 --> 00:02:43.755
lot of complicated logic, you want that component

00:02:43.755 --> 00:02:46.315
to be maybe separate in a different file

00:02:46.315 --> 00:02:47.675
and then you can just, like, call a

00:02:47.675 --> 00:02:55.740
component inside the form. At the end of

00:02:55.740 --> 00:02:57.580
the day, it's really your choice how to

00:02:57.580 --> 00:03:01.340
design your component tree. Once you go through

00:03:01.340 --> 00:03:03.340
our workshops, you'll get a better understanding of

00:03:03.340 --> 00:03:05.395
like, or a better idea of like when

00:03:05.395 --> 00:03:07.075
you want to break up a component into

00:03:07.075 --> 00:03:08.835
smaller components or when you want to merge

00:03:08.835 --> 00:03:11.955
components together. This just takes time and practice

00:03:11.955 --> 00:03:18.540
and looking at examples of good code. So

00:03:18.540 --> 00:03:20.300
a bit of practice that I'll sort of

00:03:20.300 --> 00:03:23.100
speed through because we're running out of time.

00:03:27.260 --> 00:03:29.660
Again, state is maintained by a component. And

00:03:29.660 --> 00:03:32.675
it's a bit of memory that a component

00:03:32.675 --> 00:03:36.435
maintains even after it's rendered multiple times. So

00:03:36.515 --> 00:03:39.715
think of this as something that's persisting. It's

00:03:39.715 --> 00:03:42.035
also mutable. We can mutate it using the

00:03:42.035 --> 00:03:45.075
set functions that we define when we call

00:03:45.075 --> 00:03:50.180
the useState function. And it's updated either by

00:03:50.180 --> 00:03:53.460
us when we're interacting with the website or

00:03:53.460 --> 00:03:56.580
via computers, or when we're interacting with different

00:03:56.580 --> 00:04:02.105
computers. And states essentially give us control over

00:04:02.105 --> 00:04:05.305
displaying different things in the application and actually

00:04:05.305 --> 00:04:10.425
storing that somewhere in our code. So props

00:04:10.425 --> 00:04:12.105
are a lot more surface level in that

00:04:12.105 --> 00:04:15.220
they're just passed down between components. Think of

00:04:15.220 --> 00:04:18.100
them as arguments to functions if our components

00:04:18.100 --> 00:04:21.860
are functions. And they're not mutable, and they

00:04:21.860 --> 00:04:24.260
only change when we update, for example, a

00:04:24.260 --> 00:04:26.500
state in a parent component, and it's passed

00:04:26.500 --> 00:04:29.465
down again back into a child component. That's

00:04:29.465 --> 00:04:31.225
the only time like a prop would change,

00:04:31.305 --> 00:04:38.265
if it's being changed somewhere up there. You

00:04:38.265 --> 00:04:39.945
guys just saw this. This is how we

00:04:39.945 --> 00:04:42.860
create a state. We have the value and

00:04:42.860 --> 00:04:45.660
then the setter for that value. We call

00:04:45.660 --> 00:04:48.220
uState, which is imported from React, and then

00:04:48.220 --> 00:04:50.780
we create or we give it an initial

00:04:50.780 --> 00:05:00.395
value. You guys have seen this already. So

00:05:00.555 --> 00:05:02.955
here are some examples of using our state.

00:05:03.835 --> 00:05:05.755
We want to have different states for each

00:05:05.755 --> 00:05:07.115
of the things that we care about. So

00:05:08.420 --> 00:05:11.380
persons, I guess, or people is an array.

00:05:11.540 --> 00:05:13.140
Pets is also going to be a separate

00:05:13.140 --> 00:05:15.380
array, a separate state. And then exists is

00:05:15.380 --> 00:05:17.620
going to be a Boolean. So in general,

00:05:17.620 --> 00:05:20.500
these states can take on any values. And

00:05:20.660 --> 00:05:22.500
usually, our components are going to have lots

00:05:22.500 --> 00:05:30.405
of different states. So again, we never want

00:05:30.405 --> 00:05:33.765
to modify the state directly. We always want

00:05:33.765 --> 00:05:36.805
to use the setter for the state that

00:05:36.805 --> 00:05:48.000
we define when we call useState. Okay. Another

00:05:48.000 --> 00:05:51.680
thing is when we're setting an array, we

00:05:51.680 --> 00:05:54.715
usually want to do it in this way

00:05:54.715 --> 00:05:57.835
where we destructure the initial value. So let's

00:05:57.835 --> 00:06:00.155
say pets was an array that had three

00:06:00.155 --> 00:06:03.995
values. All this is doing is flattening that

00:06:03.995 --> 00:06:07.470
array or taking away those brackets. And once

00:06:07.470 --> 00:06:09.790
we do this dot dot dot pets, this

00:06:09.790 --> 00:06:14.750
becomes three elements within this new array. It

00:06:14.750 --> 00:06:16.830
might be confusing, but we'll see an example

00:06:16.830 --> 00:06:23.645
later tomorrow. And then here's a bit of

00:06:23.645 --> 00:06:25.885
a discussion about where we actually want to

00:06:25.885 --> 00:06:31.405
store our states inside the component tree. If

00:06:31.405 --> 00:06:33.740
we're looking at a website, we see that

00:06:33.900 --> 00:06:37.740
there are a few common components between these

00:06:37.740 --> 00:06:40.220
different pages that we might view. So this

00:06:40.220 --> 00:06:43.100
is our feed. The feed has both a

00:06:43.100 --> 00:06:48.965
tabs component and a tweet panel component. And

00:06:48.965 --> 00:06:51.525
notice that these components are pretty much the

00:06:51.525 --> 00:06:56.005
same between different views of the website except

00:06:56.005 --> 00:07:02.565
that on the left, we have the posts

00:07:02.565 --> 00:07:05.030
highlighted. On the right, we have the likes

00:07:05.030 --> 00:07:09.110
highlighted. And then on the left, we have

00:07:09.110 --> 00:07:12.070
the tweets or the posts. Then on the

00:07:12.070 --> 00:07:14.230
right, we have, like, I guess the liked

00:07:14.230 --> 00:07:18.485
posts. So what this would probably look like

00:07:18.485 --> 00:07:20.725
is in the tabs component on the top,

00:07:20.805 --> 00:07:23.925
we have some state that specifies what the

00:07:23.925 --> 00:07:26.725
selected tab is. So maybe selected tab on

00:07:26.725 --> 00:07:29.685
the left is zero, which corresponds to the

00:07:29.685 --> 00:07:33.110
zero index in this array of the tabs,

00:07:33.110 --> 00:07:35.830
so posts. And then in the right, likes

00:07:35.830 --> 00:07:37.830
is or the selected tab is probably set

00:07:37.830 --> 00:07:40.390
to four, which would correspond to the likes

00:07:40.390 --> 00:07:43.030
element in the tabs. Does that make sense?

00:07:44.755 --> 00:07:47.235
And then in the tweet panel, we'd probably

00:07:47.235 --> 00:07:50.595
have a state that stores the content type.

00:07:50.995 --> 00:07:52.515
So on the left, it would be the

00:07:52.515 --> 00:07:54.195
posts, and on the right, it would be

00:07:54.195 --> 00:08:00.160
the liked posts. The problem is that there's

00:08:00.160 --> 00:08:02.160
no coordination between the states that I just

00:08:02.160 --> 00:08:05.360
described. If we just store the state within

00:08:05.360 --> 00:08:06.880
tabs and then store the state within tweet

00:08:06.880 --> 00:08:09.440
panel, when I make a change in tabs,

00:08:09.440 --> 00:08:11.360
like when I press a different tab, how

00:08:11.360 --> 00:08:13.360
does the tweet panel know that I want

00:08:13.360 --> 00:08:16.845
to update what type of tab I've selected?

00:08:18.525 --> 00:08:20.845
And the answer is I have to move

00:08:21.005 --> 00:08:23.405
the state from the tabs in the Tweet

00:08:23.405 --> 00:08:26.205
panel up to the parent component so that

00:08:26.205 --> 00:08:28.670
the parent component can then propagate the changes

00:08:28.670 --> 00:08:31.470
down to the children component because these states

00:08:31.470 --> 00:08:35.390
are related. Right? So instead of having two

00:08:35.390 --> 00:08:37.470
separate states, I would just put one state,

00:08:37.470 --> 00:08:43.365
the selected tab, up into the feed. So

00:08:43.365 --> 00:08:46.645
before encode, I would probably see, like, a

00:08:46.645 --> 00:08:49.045
state that's content type in the sweep panel,

00:08:49.045 --> 00:08:50.725
and then a state that's select the tab

00:08:50.725 --> 00:08:56.770
in the tabs component. And afterwards, I would

00:08:56.770 --> 00:08:58.930
put sort of a combined state up into

00:08:58.930 --> 00:09:01.810
the feed called selected tab that I can

00:09:01.810 --> 00:09:04.690
then pass down into each of the children

00:09:04.690 --> 00:09:16.205
components using props. So in general, if you

00:09:16.205 --> 00:09:18.205
see that you want to have states that

00:09:18.205 --> 00:09:22.525
are connected or interacting with each other in

00:09:22.525 --> 00:09:29.030
children components, move them up to that's, the,

00:09:29.030 --> 00:09:31.190
some parent that's, I guess, in common for

00:09:31.190 --> 00:09:33.270
both of them. But you don't want to

00:09:33.270 --> 00:09:35.030
move it up all the way. Move it

00:09:35.030 --> 00:09:38.550
to the least common ancestor, if you've learned

00:09:38.550 --> 00:09:44.285
some algorithms before. And then once you've moved

00:09:44.285 --> 00:09:48.125
up states to the parents, you pass down

00:09:48.125 --> 00:09:50.685
that state value as props to the children.

00:09:50.845 --> 00:09:53.245
And you might have to pass down the

00:09:53.245 --> 00:09:56.180
same state as props from one child to

00:09:56.180 --> 00:09:59.940
another child to another child if there's a

00:09:59.940 --> 00:10:08.775
large nested structure in your component tree. So

00:10:09.015 --> 00:10:12.055
another I guess to emphasize the point again,

00:10:12.055 --> 00:10:16.775
you can't share states between children components directly.

00:10:17.095 --> 00:10:19.575
You have to go through and go up

00:10:19.575 --> 00:10:21.175
to a parent component and then pass it

00:10:21.175 --> 00:10:24.070
down. I guess this is just like reiterating

00:10:24.070 --> 00:10:29.750
the point. But yeah, let's take a look

00:10:29.750 --> 00:10:33.910
again at this Twitter page breakdown. We have

00:10:33.910 --> 00:10:37.355
lots of components. The app is the outer

00:10:37.355 --> 00:10:39.915
component. And then within the app, we have

00:10:39.915 --> 00:10:44.315
a nav bar, a feed, a trending page,

00:10:44.555 --> 00:10:48.075
and a profile component. And then within the

00:10:48.075 --> 00:10:53.480
feed, we have tweets. And within the sorry,

00:10:53.480 --> 00:10:56.040
I guess it was suggestions, not profile. Within

00:10:56.040 --> 00:11:00.760
the suggestions component, have profile components. And hopefully,

00:11:00.760 --> 00:11:03.415
this tree makes a bit more sense. This

00:11:03.415 --> 00:11:05.095
is the React component tree. We have the

00:11:05.095 --> 00:11:08.935
app, which has these four children components. And

00:11:08.935 --> 00:11:11.095
then the tweet is a child of feed.

00:11:11.575 --> 00:11:16.060
Profile is a child of suggestions. So take

00:11:16.060 --> 00:11:18.780
a moment, answer this question with the neighbors

00:11:18.780 --> 00:11:21.180
around you. Which of the following should app

00:11:21.180 --> 00:13:27.905
pass down as props to these components? Bringing

00:13:27.905 --> 00:13:33.425
it back in. So the answer is we

00:13:33.425 --> 00:13:35.985
should pass down anything that might be used

00:13:35.985 --> 00:13:41.800
in multiple children components. So this includes blocked

00:13:41.800 --> 00:13:48.520
users, following, and followers. And here, on these

00:13:48.520 --> 00:13:50.840
arrows, we see which sort of props the

00:13:50.840 --> 00:13:52.840
app might want to pass down into their

00:13:52.840 --> 00:13:56.255
children. So into the feed, we'd probably want

00:13:56.255 --> 00:13:59.775
to know which users we're following, which users

00:13:59.775 --> 00:14:01.855
we have blocked, and a list of the

00:14:01.855 --> 00:14:05.695
tweets. Into trending, we want to know our

00:14:05.695 --> 00:14:09.350
following followers. And then into suggestions, we'd probably

00:14:09.350 --> 00:14:11.350
want to know following followers as well as

00:14:11.350 --> 00:14:12.870
blocked users because we don't want to see

00:14:12.870 --> 00:14:17.110
them. So the reason that we don't want

00:14:17.110 --> 00:14:19.350
list of tweets to be a prop inside,

00:14:19.430 --> 00:14:21.350
or a prop that's passed from app to

00:14:21.350 --> 00:14:23.485
feed is because it's really only used in

00:14:23.485 --> 00:14:25.485
one place. It's only used in the feed

00:14:25.485 --> 00:14:28.845
component. That means that we can actually just

00:14:28.845 --> 00:14:31.005
store state or store the list of tweets

00:14:31.005 --> 00:14:33.885
as a state in feed instead of having

00:14:33.885 --> 00:14:35.485
a state in app that's passed down to

00:14:35.485 --> 00:14:37.630
feed because none of the other children components

00:14:37.630 --> 00:14:42.110
of app need the list of suites. Whereas

00:14:42.110 --> 00:14:45.950
for the other three, we would to pass

00:14:45.950 --> 00:14:47.630
it or we would want to store an

00:14:47.630 --> 00:14:49.870
app and then pass the same values down

00:14:51.015 --> 00:14:58.935
to the children components. I'll skip past this.

00:15:00.615 --> 00:15:46.290
Any questions so far? Sorry about that. Okay.

00:15:46.530 --> 00:15:49.055
So let's talk more about the component life

00:15:49.055 --> 00:15:52.175
cycle. And this is how, like, state is

00:15:52.175 --> 00:15:57.375
managed inside of React. So you can sort

00:15:57.375 --> 00:16:01.160
of think of component rendering as a process

00:16:01.160 --> 00:16:03.960
where that's sort of like what we see

00:16:03.960 --> 00:16:09.240
in restaurants where there's a trigger. The trigger

00:16:09.240 --> 00:16:12.280
happens when a customer orders something or when

00:16:12.280 --> 00:16:15.765
we first want to or the first time

00:16:15.765 --> 00:16:20.005
a component is called, or a trigger is

00:16:20.005 --> 00:16:22.085
when one of the states in the component

00:16:22.245 --> 00:16:27.605
is changed. So after this trigger, we have

00:16:27.605 --> 00:16:31.510
the render step, which actually runs the JavaScript

00:16:31.510 --> 00:16:34.630
code in the component. So that's all the

00:16:34.630 --> 00:16:36.790
stuff, like, before the return statement in the

00:16:36.790 --> 00:16:39.590
component. And then it calls all the sub

00:16:39.590 --> 00:16:41.190
components as well that you see in the

00:16:41.190 --> 00:16:46.745
return statement. And then commit is the last

00:16:46.745 --> 00:16:49.385
step, which takes all of that JSX that

00:16:49.385 --> 00:16:52.025
we just created, or that we just obtained

00:16:52.025 --> 00:16:54.745
from the return statement, and then converts it

00:16:54.745 --> 00:16:57.625
into HTML, or adds it to, like, the

00:16:57.810 --> 00:17:01.250
DOM, which is the document object model. And

00:17:01.250 --> 00:17:03.250
then this is actually just sent to the

00:17:03.250 --> 00:17:04.930
front end or, like, the browser where we

00:17:04.930 --> 00:17:07.010
can actually see the end results or the

00:17:07.010 --> 00:17:11.970
HTML. So there's three steps, trigger, render, and

00:17:11.970 --> 00:17:15.625
commit. Trigger is like when a customer orders

00:17:15.625 --> 00:17:20.105
something, render is when the restaurant returns like

00:17:20.105 --> 00:17:22.665
what they want to be rendered, and then

00:17:22.665 --> 00:17:24.985
commit is when we actually serve it to

00:17:25.305 --> 00:17:32.860
the client. So I have an example website,

00:17:33.740 --> 00:17:36.460
and you guys can also follow along. If

00:17:36.460 --> 00:17:46.175
you visit weblabrestaurant.herokuapp.com, I guess this website has

00:17:46.175 --> 00:17:48.415
been around for a long time. This example

00:17:48.415 --> 00:17:51.295
has been around for a long time. You

00:17:51.295 --> 00:17:53.455
can see this sort of like a very,

00:17:53.455 --> 00:17:55.535
very plain React app that has a button

00:17:55.535 --> 00:18:00.370
called order stake. When you click order steak,

00:18:01.410 --> 00:18:05.650
it presents this steak and you're now given

00:18:05.650 --> 00:18:07.170
an option to send it back to the

00:18:07.170 --> 00:18:09.570
kitchen. Right now, it's a raw steak. I

00:18:09.570 --> 00:18:11.570
want it cooked. So I can send it

00:18:11.570 --> 00:18:15.065
back, and then it gives me a rarestake

00:18:15.065 --> 00:18:18.025
and then I can send it back, send

00:18:18.025 --> 00:18:21.865
it back, and keep on going. And then

00:18:21.865 --> 00:18:24.105
I'm actually gonna run it locally as well

00:18:24.265 --> 00:18:26.345
just so you guys can see the code.

00:18:27.690 --> 00:18:50.675
So the code looks like this. I have

00:18:50.675 --> 00:18:53.475
a state component. It has a state called

00:18:53.475 --> 00:18:56.940
doneness. Initially it's going to be zero. And

00:18:56.940 --> 00:18:58.860
doneness is like some value that's going to

00:18:58.860 --> 00:19:01.340
be zero, one, two, three, or five, four,

00:19:01.340 --> 00:19:05.420
or five. And then I essentially take the

00:19:05.420 --> 00:19:09.260
state and then render a different photo based

00:19:09.260 --> 00:19:11.795
on what the value of the state is.

00:19:11.795 --> 00:19:16.115
So I have like a list of these

00:19:16.115 --> 00:19:20.835
stakes, a list of images, and then, yeah,

00:19:20.835 --> 00:19:23.075
I just render it. I have a button.

00:19:23.075 --> 00:19:25.870
I have an image. All of this is

00:19:25.870 --> 00:19:28.670
actually available to you on a branch of

00:19:28.670 --> 00:19:32.350
the skeleton code. I don't know if you

00:19:32.350 --> 00:19:35.950
have access to that yet, but I'll add

00:19:35.950 --> 00:19:41.365
a link to the slides. Yeah. So what

00:19:41.365 --> 00:19:45.125
happens when we initially press the order stake

00:19:45.125 --> 00:19:48.885
button? So when we press it, this is

00:19:48.885 --> 00:19:50.325
the first time that we see the stake

00:19:50.325 --> 00:19:55.460
component. Before, there's no state component here. Afterwards,

00:19:57.220 --> 00:20:02.260
is only the first step is the trigger,

00:20:02.260 --> 00:20:04.100
or when we press the button, the trigger

00:20:04.100 --> 00:20:06.900
happens. And this first step is called mounting.

00:20:06.900 --> 00:20:09.455
So mounting is when it first appears for

00:20:09.455 --> 00:20:18.575
the first time. Afterwards, the code in the

00:20:18.575 --> 00:20:21.855
state component is run. So all of this

00:20:21.855 --> 00:20:25.480
JavaScript is run. And then we get the

00:20:25.480 --> 00:20:33.080
JSX. And then afterwards, for the committing, the

00:20:33.080 --> 00:20:36.440
HTML DOM is updated based on the JSX

00:20:36.440 --> 00:20:38.965
that we created. And then this is actually

00:20:38.965 --> 00:20:52.230
displayed to us on the website. So yeah,

00:20:52.230 --> 00:20:54.630
these are the different steps. And you might

00:20:54.630 --> 00:20:57.750
have noticed that we had this button send

00:20:57.750 --> 00:20:59.830
back to kitchen that probably looks a lot

00:21:00.550 --> 00:21:02.710
like the cat happiness button, where we just

00:21:03.015 --> 00:21:05.815
had a callback function sent to kitchen that

00:21:05.815 --> 00:21:08.935
takes the previous state, adds one, and then

00:21:08.935 --> 00:21:12.935
sets the state to that newly incremented value.

00:21:16.310 --> 00:21:19.430
Now, every time the state changes, so every

00:21:19.430 --> 00:21:26.150
time doneness changes, this triggers a rerender and

00:21:26.150 --> 00:21:30.075
we cycle again through the steps. So this

00:21:30.075 --> 00:21:33.835
set function actually is a trigger, which leads

00:21:33.835 --> 00:21:36.555
back into the render step and then the

00:21:36.555 --> 00:21:39.515
commit step, which means that every time we

00:21:39.515 --> 00:21:42.950
click the button and we change the state,

00:21:42.950 --> 00:21:46.390
we see the updated value or an updated

00:21:46.390 --> 00:21:49.830
component rather than the old component. So this

00:21:49.830 --> 00:21:51.750
is just how React works. Every time we

00:21:51.750 --> 00:22:01.635
change a state, the component's re rendered. Okay.

00:22:01.635 --> 00:22:06.355
So what happens when we delete the stake?

00:22:07.235 --> 00:22:12.250
Well, when we press delete stake, the component

00:22:12.250 --> 00:22:14.170
goes away, and this is the part of

00:22:14.170 --> 00:22:18.330
a life cycle called dismounting. So the opposite

00:22:18.330 --> 00:22:22.570
of mounting is dismounting, essentially, when we remove

00:22:22.570 --> 00:22:25.235
it from the document object model so that

00:22:25.235 --> 00:22:32.675
the HTML no longer displays that component. So

00:22:32.675 --> 00:22:35.555
that's the end of life cycle. Essentially, a

00:22:35.555 --> 00:22:39.315
component will go through three main phases. The

00:22:39.315 --> 00:22:42.290
first is mounting, where we have these trigger

00:22:42.290 --> 00:22:45.730
render and commit steps. Then a state change

00:22:45.730 --> 00:22:48.690
happens, and then we have another trigger, which

00:22:48.690 --> 00:22:51.090
is a state update, then the render, then

00:22:51.090 --> 00:22:55.765
the commit. And then we keep going through

00:22:55.765 --> 00:22:59.445
these state changes, and eventually the component is

00:22:59.445 --> 00:23:05.845
dismounted, at which point we're no longer gonna

00:23:05.845 --> 00:23:12.080
view the component. Okay, so this is a

00:23:12.080 --> 00:23:14.080
really important hook that we're going to discuss

00:23:14.080 --> 00:23:17.040
now. It's called the useEffect hook. You've seen

00:23:17.040 --> 00:23:20.800
the useState hook and useEffect is probably the

00:23:20.800 --> 00:23:23.520
second most popular hook that you're going to

00:23:23.520 --> 00:23:31.255
see. So hooks allow us to, like, access

00:23:31.255 --> 00:23:33.735
different parts of the component life cycle. We've

00:23:33.735 --> 00:23:36.935
seen that useState can update states, which trigger

00:23:37.175 --> 00:23:42.850
re renders of our components. But sometimes use

00:23:42.850 --> 00:23:46.130
state isn't enough for us. So here's an

00:23:46.130 --> 00:23:48.610
example of or here's a piece of here's

00:23:48.610 --> 00:23:50.130
a piece of code and I'll give you

00:23:50.130 --> 00:23:52.785
a minute to read through it and at

00:23:52.785 --> 00:23:55.185
the end, I'll ask you what this console

00:23:55.185 --> 00:24:29.815
dot log is gonna print. So person starts

00:24:29.815 --> 00:24:33.495
as empty. Essentially, we're setting persons to be

00:24:32.790 --> 00:24:37.750
the array that's one element, me. Who thinks

00:24:37.750 --> 00:24:42.710
that it's a? Show of hands. Who thinks

00:24:42.710 --> 00:24:51.125
it's b? More hens. So the answer is

00:24:51.125 --> 00:24:55.045
actually a. And this is really undesired behavior

00:24:55.045 --> 00:24:57.045
because we really want it so that we

00:24:57.045 --> 00:24:59.285
can access the new value of persons after

00:24:59.285 --> 00:25:04.350
we've done a set state. So it's kind

00:25:04.350 --> 00:25:06.270
of counter counter intuitive. Right? Like, we've just

00:25:06.270 --> 00:25:08.270
set the persons or we've just set the

00:25:08.270 --> 00:25:10.430
value of persons to be the array me,

00:25:11.230 --> 00:25:14.590
but once we log the value of that

00:25:14.590 --> 00:25:17.165
state, we're left with the old value and

00:25:17.165 --> 00:25:23.965
not the new value. And this is where

00:25:23.965 --> 00:25:28.060
we want to use the useEffects hook. And

00:25:28.060 --> 00:25:30.700
essentially, useEffects is useful because we can do

00:25:30.700 --> 00:25:34.620
some behavior after a state has changed. And

00:25:34.620 --> 00:25:36.140
this is just one use of the useEffects

00:25:36.140 --> 00:25:42.395
hook. So, yeah, we run it after, we

00:25:42.395 --> 00:25:46.555
run some function after a specific variable changes,

00:25:46.555 --> 00:25:48.315
and this variable is usually like a state

00:25:48.315 --> 00:25:57.020
in our component. And you'll see a bit

00:25:57.020 --> 00:26:00.220
of this later, but commonly this is used

00:26:00.220 --> 00:26:05.100
to do some complicated functionality that's external to

00:26:05.100 --> 00:26:14.455
React whenever some state changes. And the syntax

00:26:14.455 --> 00:26:17.415
is this. We have useEffects that takes in

00:26:17.415 --> 00:26:22.840
two arguments. The first is a function. This

00:26:22.840 --> 00:26:27.800
can be like a callback function. And the

00:26:27.800 --> 00:26:31.480
second is a dependency array. It's gonna be

00:26:31.480 --> 00:26:35.145
literally an array. And this is optional, so

00:26:35.145 --> 00:26:37.705
we can either have a dependency array or

00:26:38.665 --> 00:26:43.065
just have one argument being the function. And

00:26:43.065 --> 00:26:45.865
if we do have the dependency array, then

00:26:46.460 --> 00:26:48.940
this use effect tells us that whenever anything

00:26:48.940 --> 00:26:52.940
inside this array changes, we call this function.

00:26:56.460 --> 00:26:58.780
Okay. So for example, we have this callback

00:26:58.780 --> 00:27:02.065
function, or we have this function by function

00:27:02.065 --> 00:27:04.465
that does something, and then we have three

00:27:04.465 --> 00:27:06.705
useEffects here that all look sort of different

00:27:06.705 --> 00:27:11.505
based on, because of the dependency array. So,

00:27:11.985 --> 00:27:15.820
this first useEffects, and let's assume that var

00:27:15.820 --> 00:27:19.740
one and var two are states, my function

00:27:19.740 --> 00:27:23.500
is called both after the initial render and

00:27:23.500 --> 00:27:25.980
after either var one or var two has

00:27:25.980 --> 00:27:31.855
changed. And this is a pretty common use

00:27:31.855 --> 00:27:34.735
of useEffects. I think this is probably the

00:27:35.375 --> 00:27:38.015
first or second most common case of useEffect

00:27:38.015 --> 00:27:44.040
that you might be using. If this dependency

00:27:44.040 --> 00:27:48.680
array is empty, my function's only going to

00:27:48.680 --> 00:27:51.560
be called on the first render or upon

00:27:51.560 --> 00:27:58.485
mounting. So notice whenever a dependency array is

00:27:59.285 --> 00:28:05.605
specified, my function will be called upon mounts.

00:28:05.925 --> 00:28:07.365
And then if you do have something within

00:28:07.365 --> 00:28:10.720
the dependency array, my function will also be

00:28:10.720 --> 00:28:17.280
called whenever one of those values changes. And

00:28:17.280 --> 00:28:19.280
then the third case is if we have

00:28:19.280 --> 00:28:23.735
no dependency array. And this actually changes, or

00:28:23.735 --> 00:28:26.375
this calls my function at every single rerender.

00:28:26.935 --> 00:28:28.935
So the first time as well as when

00:28:28.935 --> 00:28:31.575
any other state changes. So this is just

00:28:31.575 --> 00:28:34.695
like, it always changes. Usually you won't see

00:28:34.695 --> 00:28:36.970
it a lot because you usually want some

00:28:36.970 --> 00:28:40.250
functionality or some function to call only when

00:28:40.250 --> 00:28:44.330
you change some specific state. So you're only

00:28:44.330 --> 00:28:46.810
only gonna see like the first two cases

00:28:46.970 --> 00:28:54.625
the most often. Okay, any questions about these

00:28:54.625 --> 00:29:10.620
three uses of useEffects? Alright. So now, instead

00:29:10.620 --> 00:29:12.620
of having the code from before where we

00:29:12.620 --> 00:29:15.260
try to console log persons right after we

00:29:15.260 --> 00:29:19.805
do the set, We can have a useEffects

00:29:19.965 --> 00:29:22.685
that takes in persons, the state, as a

00:29:22.685 --> 00:29:27.005
dependency so that any time persons changes, the

00:29:27.005 --> 00:29:30.125
function that's the first argument of the useEffects,

00:29:30.125 --> 00:29:35.140
which is this callback function, is called. So

00:29:36.500 --> 00:29:39.620
if we called the function testing stuff, it

00:29:39.620 --> 00:29:41.940
would change persons because it adds me to

00:29:41.940 --> 00:29:45.940
the end of it. And then it would

00:29:46.905 --> 00:29:49.385
the useEffects would run because it sees that

00:29:49.385 --> 00:29:53.145
persons has changed and then the console dot

00:29:53.145 --> 00:29:56.905
log function would be called. At this point,

00:29:56.905 --> 00:29:59.145
because it has the updated value of persons,

00:29:59.145 --> 00:30:01.690
because it knows that it has changed, console

00:30:01.690 --> 00:30:04.410
dot log persons is gonna print the new

00:30:04.410 --> 00:30:07.450
value which is the array with me at

00:30:07.450 --> 00:30:17.855
the end. And then one more thing with

00:30:17.855 --> 00:30:19.775
the callback function that you passed into use

00:30:19.775 --> 00:30:37.170
effects. My computer died. Yeah. Like 30 something.

00:31:29.940 --> 00:31:50.615
Sorry about that. So if you pass a

00:31:50.615 --> 00:31:52.295
function that has a return statement at the

00:31:52.295 --> 00:31:55.415
end, the function at the end is actually

00:31:55.415 --> 00:31:58.550
gonna be run whenever the component dismounts. So

00:31:58.550 --> 00:32:00.390
you can think of it as a cleanup

00:32:00.390 --> 00:32:05.670
function. Usually, it's gonna do something like disconnect

00:32:05.670 --> 00:32:09.030
from an external service. If at the beginning

00:32:09.030 --> 00:32:10.870
of the, or at the beginning of the

00:32:10.870 --> 00:32:13.945
render, when you first mounted, you did connect

00:32:13.945 --> 00:32:18.665
to it. We'll see an example of this

00:32:18.825 --> 00:32:21.385
return callback function being used in a bit.

00:32:26.330 --> 00:32:28.970
And this step deals with the dismount part

00:32:28.970 --> 00:32:36.970
of the life cycle. Okay. Any questions? I

00:32:36.970 --> 00:32:39.530
know this was pretty fast. Any questions about

00:32:39.530 --> 00:33:05.860
like how useEffect works? Okay. Here are some

00:33:05.860 --> 00:33:07.620
common patterns in React that you might see.

00:33:08.585 --> 00:33:31.530
That's just, oh yeah. Yeah, so the question

00:33:31.530 --> 00:33:36.105
is like, how did useEffect solve the problem

00:33:36.105 --> 00:33:41.385
where after we set persons, we couldn't see

00:33:41.385 --> 00:33:47.810
the updated value? Yeah, essentially set persons is

00:33:47.810 --> 00:33:51.170
kind of has like, you're not exactly sure

00:33:51.170 --> 00:33:53.890
like how long it'll take slash it doesn't

00:33:53.890 --> 00:33:57.170
run immediately. And because of that, when we

00:33:57.170 --> 00:34:00.130
call set persons and then immediately after try

00:34:00.130 --> 00:34:03.505
to log like the thing that we supposedly

00:34:03.505 --> 00:34:05.505
just updated, it's not gonna have the most

00:34:05.505 --> 00:34:09.985
updated version. Whereas, if we call set persons

00:34:09.985 --> 00:34:12.785
and then have a use effect that specifically

00:34:12.785 --> 00:34:15.505
looks at like whenever the person's state changes,

00:34:16.065 --> 00:34:19.180
then this is gonna recognize, oh, once it

00:34:19.180 --> 00:34:22.300
changes, I'll have the new value so then

00:34:22.300 --> 00:34:29.100
I can log the new value here. Yeah.

00:34:45.330 --> 00:34:48.130
Oh yeah, so dot dot dot persons sort

00:34:48.130 --> 00:34:50.450
of just like flattens or like takes the

00:34:50.450 --> 00:34:54.370
elements of persons and like removes like the

00:34:54.370 --> 00:34:58.905
array around it sort of. Yeah. So like

00:34:59.225 --> 00:35:01.705
the end result is gonna be like still

00:35:01.945 --> 00:35:04.345
a full array of like all the people.

00:35:04.345 --> 00:35:06.185
It's not gonna be like one array and

00:35:06.185 --> 00:35:19.060
then a string or something. Okay. Yeah, so

00:35:19.060 --> 00:35:20.340
one thing that you might see a lot

00:35:20.340 --> 00:35:28.815
is conditional rendering. So in JSX, we're pretty

00:35:28.815 --> 00:35:31.935
much like using quote unquote HTML tags to

00:35:31.935 --> 00:35:39.460
render stuff. And we can sort of put

00:35:39.460 --> 00:35:43.380
these elements or reference these elements using these

00:35:43.380 --> 00:35:46.900
curly braces to escape out of like JSX.

00:35:47.220 --> 00:35:49.060
So if we're returning this div and we

00:35:49.060 --> 00:35:50.900
want to have like both the header and

00:35:50.900 --> 00:35:53.885
the content show up, even though these are

00:35:53.965 --> 00:35:58.125
JSX elements, we can still sort of insert

00:35:58.125 --> 00:36:01.565
them into this div by using these curly

00:36:01.565 --> 00:36:11.330
braces. So take a minute to guess or

00:36:11.330 --> 00:36:13.570
sort of oh, you've I think you guys

00:36:13.570 --> 00:36:16.930
have seen this conditional rendering but just take

00:36:16.930 --> 00:36:18.450
a minute to talk to the person around

00:36:18.450 --> 00:36:22.605
you. What is this code doing? Like based

00:36:22.605 --> 00:36:24.125
on the value of loading which is either

00:36:24.125 --> 00:36:50.475
true or false, what will it display? Hopefully

00:36:50.475 --> 00:36:53.755
you know it. When loading is true, it's

00:36:53.755 --> 00:36:56.315
going to display the first part. So everything

00:36:56.315 --> 00:36:59.810
between these two parentheses. And then when loading

00:36:59.810 --> 00:37:04.850
is false, it'll display everything between the next

00:37:04.850 --> 00:37:08.610
set of parentheses. And this is a common

00:37:08.610 --> 00:37:10.850
structure that you'll see a lot. We'll have

00:37:10.850 --> 00:37:14.205
this like conditional rendering that uses a ternary

00:37:14.205 --> 00:37:17.885
statement where we have a condition that's gonna

00:37:17.885 --> 00:37:21.325
evaluate to either true or false and then

00:37:21.325 --> 00:37:24.605
a question mark. And between this question mark

00:37:24.605 --> 00:37:26.365
and the colon is gonna be what we

00:37:26.365 --> 00:37:28.780
want to render or return if the result

00:37:28.780 --> 00:37:33.180
is true, if this condition is true. And

00:37:33.180 --> 00:37:34.460
then what we want to render if the

00:37:34.460 --> 00:37:42.215
condition is false after the colon. Let's get

00:37:42.215 --> 00:37:45.095
past that. Another thing you might want to

00:37:45.095 --> 00:37:46.935
do a lot is render an array of

00:37:46.935 --> 00:37:52.375
data. A lot of the time you'll be

00:37:52.375 --> 00:37:55.610
like you'll have a state that has that's

00:37:55.610 --> 00:37:57.370
like an array of data, perhaps like a

00:37:57.370 --> 00:38:00.010
drop down menu, like selections for that, or

00:38:00.010 --> 00:38:02.090
a list of data items in a database.

00:38:03.930 --> 00:38:05.450
You can use the map function that we

00:38:05.450 --> 00:38:08.810
talked about in the morning to map elements

00:38:08.810 --> 00:38:16.395
and arrays, to, I guess, a quick review

00:38:16.395 --> 00:38:19.035
of map. Map, like, takes an element in

00:38:19.035 --> 00:38:22.795
array, or takes an array and then receives

00:38:22.795 --> 00:38:25.400
a callback function that takes an element of

00:38:25.400 --> 00:38:28.680
the array and then returns something else. So

00:38:30.040 --> 00:38:31.640
we saw in the morning that we could

00:38:31.640 --> 00:38:34.600
do, like, Celsius to Fahrenheit and then map

00:38:34.600 --> 00:38:37.800
all of these Celsius values to Fahrenheit values

00:38:37.960 --> 00:38:40.555
by passing in a callback function that takes

00:38:40.555 --> 00:38:43.355
a Celsius value and returns the Fahrenheit value.

00:38:45.355 --> 00:38:47.195
So we can do the same thing or

00:38:47.195 --> 00:38:53.675
use the same idea to map arrays, that

00:38:53.675 --> 00:38:58.630
might not be like, renderable in React to

00:39:01.910 --> 00:39:05.270
things that are actually renderable in React, essentially

00:39:05.350 --> 00:39:09.295
JSX elements like divs. So if we create

00:39:09.295 --> 00:39:11.455
a callback function that takes like an element

00:39:11.455 --> 00:39:13.615
of an array like this that's sort of

00:39:13.615 --> 00:39:17.135
an object and puts the item name in

00:39:17.135 --> 00:39:20.895
a div, and I guess returns like a

00:39:20.895 --> 00:39:24.390
div with the name inside, then we can

00:39:24.390 --> 00:39:28.710
map the entire array to this array of

00:39:28.710 --> 00:39:36.390
like divs using the map function. So this

00:39:36.390 --> 00:39:40.385
would look like something like this where we

00:39:40.385 --> 00:39:43.745
have data which is an array of objects.

00:39:45.665 --> 00:39:47.825
And then we have this callback function that

00:39:47.825 --> 00:39:50.945
takes an element of this array and maps

00:39:50.945 --> 00:39:55.550
it to or returns a div that had

00:39:55.710 --> 00:39:58.590
that uses like the the items inside the

00:39:58.590 --> 00:40:02.830
object. And we pass that callback function into

00:40:02.830 --> 00:40:05.870
this map function and we call data dot

00:40:05.870 --> 00:40:09.555
map with the callback function as argument. And

00:40:09.955 --> 00:40:11.955
all this code is essentially the same thing

00:40:11.955 --> 00:40:16.035
as if we just returned two divs that

00:40:16.035 --> 00:40:19.555
looked like this. And the top code is

00:40:19.555 --> 00:40:24.770
just a lot more concise and, yeah. Easy

00:40:24.770 --> 00:40:28.290
to understand slash you can update the data

00:40:28.290 --> 00:40:29.570
and then don't have you don't have to

00:40:29.570 --> 00:40:34.050
change like the return here. All you need

00:40:34.050 --> 00:40:36.370
to do is like add elements to the

00:40:36.370 --> 00:40:40.035
actual data state and that makes it so

00:40:40.035 --> 00:40:41.475
that you don't have to like actually create

00:40:41.475 --> 00:40:45.715
new divs every time your data array changes.

00:40:51.640 --> 00:40:55.880
And a quick note about this key. The

00:40:55.880 --> 00:41:03.800
key is used maybe it's not here. But

00:41:03.800 --> 00:41:05.160
the key makes it so that if you

00:41:05.160 --> 00:41:11.005
have like a unique key, React recognizes it

00:41:11.005 --> 00:41:16.205
helps React like prevent unnecessary re renders. I

00:41:16.205 --> 00:41:17.245
guess you don't have to worry about it

00:41:17.245 --> 00:41:18.605
so much, but you might see it in

00:41:18.605 --> 00:41:21.160
future workshops. Try to make it so that

00:41:21.160 --> 00:41:25.160
all your components inside all your like JSOX

00:41:25.160 --> 00:41:28.680
elements inside a component have different keys. Especially

00:41:28.680 --> 00:41:31.160
when they're like very similar elements like comments

00:41:31.160 --> 00:41:40.165
or like divs and stuff. Yeah, as a

00:41:40.165 --> 00:41:44.005
quick exercise, like what would this code look

00:41:44.005 --> 00:41:46.325
like if we tried to write it without

00:41:46.325 --> 00:41:51.710
the map? It's pretty much the same thing

00:41:51.710 --> 00:41:58.830
as before or the previous slide. It would

00:41:58.910 --> 00:42:00.510
essentially look the same as if we had

00:42:00.510 --> 00:42:04.915
two item components with the text passed into

00:42:04.915 --> 00:42:08.995
here. But instead, we use map so that

00:42:09.235 --> 00:42:16.120
we can reuse the same like logic. And

00:42:16.120 --> 00:42:17.320
that way we don't have to write out

00:42:17.320 --> 00:42:19.640
each of these different components. We can just

00:42:20.920 --> 00:42:24.120
take an array with like values that we

00:42:24.120 --> 00:42:26.120
might more commonly use and then map it

00:42:26.120 --> 00:42:39.435
to these JSX components. And then finally, you

00:42:39.435 --> 00:42:41.275
might see a lot of like fetching and

00:42:41.275 --> 00:42:43.675
sending data from a server, but we'll see

00:42:43.675 --> 00:42:48.070
more of this tomorrow. And a few minutes

00:42:48.070 --> 00:42:50.150
just for questions. I think we're running out

00:42:50.150 --> 00:42:51.910
of time, so the rest of this lecture

00:42:51.910 --> 00:42:55.670
will be moved to tomorrow morning. Any questions

00:42:55.670 --> 00:43:00.085
about maybe those last two parts like conditional

00:43:00.085 --> 00:43:11.445
renderingmapping in JavaScript? Okay. If not, happy we'll

00:43:11.445 --> 00:43:15.820
give some announcements. So today's really gonna be

00:43:15.820 --> 00:43:18.460
a lot of recap about React. We're gonna

00:43:18.460 --> 00:43:20.620
start with components, looking at like the use

00:43:20.620 --> 00:43:23.100
state hook. Then we're gonna talk about a

00:43:23.100 --> 00:43:27.115
new concept called the React Virtual Dom. And

00:43:27.115 --> 00:43:29.355
that leads us into the component life cycle.

00:43:29.515 --> 00:43:33.195
I think I referenced the DOM yesterday while

00:43:33.195 --> 00:43:35.915
explaining the component life cycle. I realized I

00:43:35.915 --> 00:43:37.755
probably should have talked about it before because

00:43:37.755 --> 00:43:39.920
it's quite important to know in order to

00:43:39.920 --> 00:43:42.000
have the proper context for the component life

00:43:42.000 --> 00:43:45.600
cycle. And then, finally, we'll look one more

00:43:45.600 --> 00:43:49.680
time at useEffects. And then, to combine all

00:43:49.680 --> 00:43:51.520
of the knowledge that we learned, we're gonna

00:43:51.520 --> 00:43:53.205
walk through an example of creating a React

00:43:53.205 --> 00:43:57.205
app from scratch, and we'll implement a simple

00:43:57.205 --> 00:44:01.445
timer that uses useState, useEffects, and then has

00:44:01.445 --> 00:44:06.085
nested components. Everything that you might see in

00:44:06.085 --> 00:44:09.260
a standard app will be in the app

00:44:09.260 --> 00:44:14.700
that we create, hopefully. So a quick recap

00:44:14.700 --> 00:44:19.180
about React components. Essentially, at a very surface

00:44:19.180 --> 00:44:22.780
level component is a very powerful HTML element.

00:44:24.285 --> 00:44:26.845
You've seen HTML elements before on day one.

00:44:26.845 --> 00:44:30.125
We can have like buttons and closes the

00:44:30.125 --> 00:44:31.885
text click me and it's gonna look something

00:44:31.885 --> 00:44:37.005
like that. And in React, to create a

00:44:37.005 --> 00:44:38.925
button in our UI, it's gonna be very

00:44:38.925 --> 00:44:41.280
similar. The way we do it is we

00:44:41.280 --> 00:44:45.520
create a function called whatever we want, like

00:44:45.520 --> 00:44:49.920
button, that at the end returns some element,

00:44:50.400 --> 00:44:52.880
and this eventually renders into the same thing

00:44:52.880 --> 00:44:54.160
that we would see if we did it

00:44:54.160 --> 00:45:00.745
in HTML. So let's analyze the components of

00:45:00.745 --> 00:45:05.225
a component again. First, I really want to

00:45:05.225 --> 00:45:08.745
emphasize that components are JavaScript functions. They're not

00:45:08.745 --> 00:45:12.790
classes. If you ever search up React documentation

00:45:12.790 --> 00:45:15.030
online, you're probably gonna get a lot of

00:45:15.030 --> 00:45:19.590
conflicting feedback about what components are supposed to

00:45:19.590 --> 00:45:22.550
look like. In old React, components used to

00:45:22.550 --> 00:45:24.475
be defined as classes. It would be like

00:45:24.475 --> 00:45:27.755
class button extends React component or something like

00:45:27.755 --> 00:45:31.435
that. Nowadays, components are always gonna be functions,

00:45:31.435 --> 00:45:33.915
and it just makes React much faster, and

00:45:33.915 --> 00:45:37.900
it's really just the standard now. And it

00:45:37.900 --> 00:45:39.820
doesn't matter if you use a callback in

00:45:39.820 --> 00:45:42.220
the way that this is being defined, or

00:45:42.220 --> 00:45:45.180
if you do something like function button with

00:45:45.180 --> 00:45:47.420
the open and close parentheses. It's going to

00:45:47.420 --> 00:45:52.795
mean the same thing. And then the other

00:45:52.795 --> 00:45:55.595
key part is that components use JSX, which

00:45:55.595 --> 00:45:57.595
is similar to HTML, but it's not exactly

00:45:57.595 --> 00:46:00.715
HTML. One key difference that you might have

00:46:00.715 --> 00:46:02.955
seen before was that instead of class, you

00:46:02.955 --> 00:46:07.550
use class name, And then also inside JSX,

00:46:07.550 --> 00:46:11.390
you can escape and have JavaScript code, whereas

00:46:11.390 --> 00:46:14.270
in HTML, you can't really do the exact

00:46:14.270 --> 00:46:19.705
same thing. And then components are powerful because

00:46:19.705 --> 00:46:25.225
within the component, declaring it and then telling

00:46:25.225 --> 00:46:26.905
it what to render, we can have a

00:46:26.905 --> 00:46:30.185
lot of complex logic. The most common piece

00:46:30.185 --> 00:46:32.425
of logic that you'll see is storing state.

00:46:33.060 --> 00:46:34.900
State is like a piece of memory that

00:46:34.900 --> 00:46:38.900
resides within a component, and after it renders,

00:46:38.900 --> 00:46:41.460
state persists. So, that makes it so that

00:46:41.460 --> 00:46:43.540
we can have a consistent piece of memory

00:46:45.235 --> 00:46:47.235
that we can do other stuff with, for

00:46:47.235 --> 00:46:48.915
example, the use effects hook that we saw

00:46:48.915 --> 00:46:53.875
yesterday. And this is something that HTML just

00:46:53.875 --> 00:46:58.035
really struggles to do. It's very complicated to

00:46:58.035 --> 00:47:02.710
have state in HTML. And yeah, this is

00:47:02.710 --> 00:47:04.870
one of the main reasons why React is

00:47:04.870 --> 00:47:13.765
so powerful. Looking at the useState hook, hopefully,

00:47:13.765 --> 00:47:15.685
you're familiar with this by now. We have

00:47:15.685 --> 00:47:19.125
the state declared here. We have the state

00:47:19.125 --> 00:47:23.525
set function declared here. This is an array

00:47:23.525 --> 00:47:28.050
with two elements, and uState with an initial

00:47:28.050 --> 00:47:31.250
value with whatever you want it to be

00:47:31.490 --> 00:47:33.650
evaluates to an array with two elements where

00:47:33.650 --> 00:47:34.930
the first one is the state, the second

00:47:34.930 --> 00:47:36.690
one is the function. So this is how

00:47:36.690 --> 00:47:42.515
you create a state in React. And now,

00:47:42.515 --> 00:47:45.475
let's take a look at the bottom of

00:47:45.475 --> 00:47:48.755
the component where we return. So, components are

00:47:48.755 --> 00:47:51.155
always gonna be made up of JSX elements,

00:47:51.155 --> 00:47:53.970
which are pretty much like the HTML elements,

00:47:53.970 --> 00:47:56.210
as well as other components. Only these two

00:47:56.210 --> 00:48:00.530
types. So, what this means is that if

00:48:00.530 --> 00:48:02.690
you sort of think of like a component

00:48:03.250 --> 00:48:05.505
being a parent then its children are all

00:48:05.505 --> 00:48:07.985
of the elements that are rendered by it,

00:48:08.785 --> 00:48:10.545
all of its children are either gonna be

00:48:10.545 --> 00:48:14.145
JSX elements and components. So recursively, if you

00:48:14.145 --> 00:48:16.385
go all the way down a tree, eventually

00:48:16.385 --> 00:48:18.625
all the leaves should be JSX elements. You

00:48:18.625 --> 00:48:25.400
shouldn't have any components in the leaves. And,

00:48:25.400 --> 00:48:28.520
yeah. So, React is really powerful because you

00:48:28.520 --> 00:48:32.520
can nest components within other components. In this

00:48:32.575 --> 00:48:34.575
simple example, we have the button that we

00:48:34.575 --> 00:48:39.375
saw before being nested inside a form. And

00:48:39.375 --> 00:48:43.135
to render the form, what we do is

00:48:43.135 --> 00:48:45.935
we first render this JSX element, which is

00:48:45.935 --> 00:48:49.730
a header that just looks like that. And

00:48:49.730 --> 00:48:54.290
then we recursively render any components inside this

00:48:54.290 --> 00:48:58.450
component. So we recursively render button, and button

00:48:58.450 --> 00:49:01.730
renders as just the JSX element that's button,

00:49:02.425 --> 00:49:11.465
so it looks like that. And the key

00:49:11.465 --> 00:49:13.945
thing to remember is these components are all

00:49:13.945 --> 00:49:17.260
functions. So when we render something, essentially all

00:49:17.260 --> 00:49:19.500
we're doing is running the function that defines

00:49:19.500 --> 00:49:22.780
the component. So when we render form, we're

00:49:22.780 --> 00:49:25.340
running this entire function, and at the end,

00:49:25.340 --> 00:49:28.300
we're returning a value, but to determine what

00:49:28.300 --> 00:49:31.205
this value actually is, we have to resolve

00:49:31.205 --> 00:49:33.445
what the value of button is. And then,

00:49:33.925 --> 00:49:36.485
going to the definition for button, we have

00:49:36.485 --> 00:49:40.485
another function that we run or call, and

00:49:40.485 --> 00:49:41.925
then we get a return value for that,

00:49:42.500 --> 00:49:44.580
and then we get that return value and

00:49:44.580 --> 00:49:47.860
place it where this is, and then we

00:49:47.860 --> 00:49:50.420
keep propagating up until we can get a

00:49:50.420 --> 00:49:53.780
full return value that's not consisting of any

00:49:53.780 --> 00:49:58.675
components and only JSX elements. Any questions so

00:49:58.675 --> 00:50:10.530
far? Okay. So remembering this nesting structure, let's

00:50:10.530 --> 00:50:15.890
now visit the React Virtual Dom. Previously, we've

00:50:15.890 --> 00:50:18.210
seen React component trees, which is like a

00:50:18.210 --> 00:50:22.370
tree structure that shows the relationships between parent

00:50:22.370 --> 00:50:27.065
and children components. And notice that this tree

00:50:27.065 --> 00:50:29.225
doesn't have any JSX elements, and that's just

00:50:29.225 --> 00:50:31.305
because we usually only care about the relationships

00:50:31.305 --> 00:50:35.465
between components, because between components we're passing down

00:50:35.465 --> 00:50:38.265
props, and that's where a lot of our

00:50:38.265 --> 00:50:39.865
logic in the app is gonna be in.

00:50:40.400 --> 00:50:42.960
We don't care a lot about passing down

00:50:42.960 --> 00:50:46.000
props or, I guess, passing down values into

00:50:46.000 --> 00:50:48.400
JSX elements because usually that's a lot more

00:50:48.400 --> 00:50:51.520
surface level. So our component trees are gonna

00:50:51.520 --> 00:50:58.625
be all components, whereas React's virtual DOMs are

00:50:58.625 --> 00:51:00.705
gonna be different, where it's gonna be all

00:51:00.705 --> 00:51:02.545
JSX elements, and we'll see that in a

00:51:02.545 --> 00:51:05.905
bit. Let me first explain what a DOM

00:51:05.905 --> 00:51:11.150
is. It's a document object model, So the

00:51:11.150 --> 00:51:13.710
way to remember is it's a model that

00:51:14.990 --> 00:51:18.190
shows or represents the objects that comprise of

00:51:18.190 --> 00:51:21.870
a document. So what is a document? Well,

00:51:21.870 --> 00:51:24.030
a document in the context that we're speaking

00:51:24.030 --> 00:51:25.905
in is just like the website that you

00:51:25.905 --> 00:51:27.585
see or the web page that you see.

00:51:27.745 --> 00:51:31.585
So this is probably like an HTML, like

00:51:32.305 --> 00:51:35.665
if I open Google, for example, this is

00:51:35.665 --> 00:51:39.730
a website, and all these HTML elements can

00:51:39.730 --> 00:51:45.730
be represented using a DOM format. At the

00:51:45.730 --> 00:51:48.050
very top, we have document, and then we

00:51:48.050 --> 00:51:50.930
have the HTML root element, and we have

00:51:50.930 --> 00:51:53.955
head and body, as we saw before, and

00:51:53.955 --> 00:51:56.835
then head as title and so on. And

00:51:56.835 --> 00:52:00.035
we can sort of more cleanly represent this

00:52:00.035 --> 00:52:06.290
as a tree like this. The DOM isn't

00:52:06.290 --> 00:52:09.570
exactly the same as HTML. DOM is just,

00:52:09.570 --> 00:52:12.770
I think, like a more general sort of

00:52:12.770 --> 00:52:15.250
data structure, but you can use DOM to

00:52:15.250 --> 00:52:20.595
represent HTML, and similarly, you can use DOM

00:52:20.595 --> 00:52:25.315
to represent your React components. So React creates

00:52:25.315 --> 00:52:29.155
a virtual DOM of all of your components

00:52:29.155 --> 00:52:31.555
whenever it renders to the website or to

00:52:31.555 --> 00:52:36.040
the browser. So virtual DOM is virtual because

00:52:36.280 --> 00:52:39.640
React uses it internally. It's not exactly the

00:52:39.640 --> 00:52:41.800
same DOM that gets displayed on the browser.

00:52:41.800 --> 00:52:46.365
The browser has its own DOM, but we'll

00:52:46.365 --> 00:52:48.285
see why React wants to keep track of

00:52:48.285 --> 00:52:56.365
its own virtual DOM in three sections. To

00:52:56.365 --> 00:52:59.430
create the virtual DOM, essentially just recursively renders

00:52:59.430 --> 00:53:03.990
each component from the root, and then, let's

00:53:03.990 --> 00:53:07.350
say component x has these JSX elements, but

00:53:07.350 --> 00:53:11.315
then also calls or has this component a

00:53:11.315 --> 00:53:14.675
nested in it, then component a probably resolves

00:53:14.675 --> 00:53:18.035
into these five JSX elements, and that's how

00:53:18.035 --> 00:53:21.155
we get this virtual DOM for the component

00:53:21.155 --> 00:53:31.110
x. Okay. So, hopefully, that's enough context now

00:53:31.110 --> 00:53:32.630
for us to talk about the component life

00:53:32.630 --> 00:53:37.670
cycle. There are three steps, or three phases.

00:53:38.515 --> 00:53:41.155
The first is mounting, the second is updating,

00:53:41.155 --> 00:53:43.315
and then the third is dismounting. So think

00:53:43.315 --> 00:53:45.795
of it sort of as like the first

00:53:45.795 --> 00:53:48.435
and third steps are like opposites of each

00:53:48.435 --> 00:53:50.115
other, and then the second step is like

00:53:50.115 --> 00:53:51.795
a phase where we're just sort of in

00:53:51.795 --> 00:53:56.550
a limbo and repeating. Sometimes you'll see this

00:53:56.550 --> 00:54:02.550
mounting called unmounting online. Yeah, so mounting is

00:54:02.550 --> 00:54:04.310
the process of adding a component to the

00:54:04.310 --> 00:54:07.030
DOM or the virtual DOM. So let's say

00:54:07.030 --> 00:54:09.895
our virtual DOM initially looks like this. Mounting

00:54:09.895 --> 00:54:11.975
is a phase where we add a component,

00:54:11.975 --> 00:54:13.895
let's say component a, to the virtual DOM

00:54:13.895 --> 00:54:20.375
so that it now looks like this. And

00:54:20.375 --> 00:54:23.015
then updating is whenever we still have the

00:54:23.015 --> 00:54:25.750
component, it's not gone yet from the virtual

00:54:25.750 --> 00:54:29.670
DOM, but we change parts of it, and

00:54:29.670 --> 00:54:32.150
these are caused by triggers, which cause re

00:54:32.150 --> 00:54:34.790
renders, which cause the virtual DOM to change

00:54:34.790 --> 00:54:37.510
for that component, which causes the entire virtual

00:54:37.510 --> 00:54:45.025
DOM to change. So this is usually when

00:54:45.265 --> 00:54:48.865
or the phase that our components usually stay

00:54:48.865 --> 00:54:52.465
in. Oftentimes, we have a state that changes

00:54:52.465 --> 00:54:54.640
within a component, and every time we change

00:54:54.640 --> 00:54:57.760
the state, it's not like the component's dismounted

00:54:57.760 --> 00:55:02.000
and then mounted again. It's just updated, and

00:55:02.000 --> 00:55:03.520
React does that so it doesn't have to,

00:55:03.520 --> 00:55:05.680
like, do all the work of dismounting, mounting,

00:55:05.680 --> 00:55:07.600
dismounting, mounting every time a state or a

00:55:07.600 --> 00:55:13.525
prop changes. And then the last step is

00:55:13.525 --> 00:55:16.965
dismounting, which is when it actually is removed

00:55:16.965 --> 00:55:28.510
from the React Virtual DOM. Okay. So, I

00:55:28.510 --> 00:55:29.870
want you to take a minute to visit

00:55:29.870 --> 00:55:36.110
this website again, weblabrestaurant.herokuapp.com. And I'll pull it

00:55:36.110 --> 00:55:40.815
up. And see if you can, like, identify

00:55:40.815 --> 00:55:43.535
the places where a component's being mounted, where

00:55:43.535 --> 00:55:46.015
it's in the updating phase, and then where

00:55:46.015 --> 00:56:40.185
it's being dismounted. So for the sake of

00:56:40.185 --> 00:56:43.785
time, I'll just go through it. So to

00:56:43.785 --> 00:56:46.820
help me, I guess, provide evidence that it's

00:56:46.820 --> 00:56:50.740
actually being mounted slash just mounted, I'm gonna

00:56:50.740 --> 00:56:53.460
right click and then press inspect and then

00:56:53.460 --> 00:56:57.140
go to elements. This shows us the browser's

00:56:57.140 --> 00:57:00.985
HTML that it's rendering. And I'm gonna expand

00:57:00.985 --> 00:57:02.505
this div so that we can see all

00:57:02.505 --> 00:57:06.425
of the inner components or the inner elements.

00:57:07.545 --> 00:57:09.225
Okay. So now I'm gonna press the order

00:57:09.225 --> 00:57:13.690
stick button, And notice that this div appeared.

00:57:13.690 --> 00:57:16.330
This div wasn't here earlier, and this is

00:57:16.330 --> 00:57:19.530
probably indicative that the component that this is

00:57:19.530 --> 00:57:22.490
being rendered by just got mounted, and it

00:57:22.490 --> 00:57:24.410
just got added to the dom, which is

00:57:24.410 --> 00:57:26.410
why it's showing up in the HTML file.

00:57:31.335 --> 00:57:36.215
Pressing this button triggered the mounting phase, and

00:57:36.215 --> 00:57:37.895
then now when I press this new button

00:57:37.895 --> 00:57:41.280
inside the component, my guess is that a

00:57:41.280 --> 00:57:43.520
state is changing within the component, which is

00:57:43.520 --> 00:57:47.840
causing the component to be in the update

00:57:47.840 --> 00:57:52.240
phase. So it's re rendering every time I

00:57:52.240 --> 00:57:57.055
press this button. And then finally, when I

00:57:57.055 --> 00:57:59.295
press delete stake, notice that this div is

00:57:59.295 --> 00:58:03.055
gonna disappear. And this is pretty good evidence

00:58:03.055 --> 00:58:12.975
that now that component was just dismounted. And

00:58:11.910 --> 00:58:13.750
actually, yeah, we'll just leave it at that.

00:58:14.070 --> 00:58:25.525
Any questions about that? Okay. So, I have

00:58:25.525 --> 00:58:28.805
a question. There's a word that I'm looking

00:58:28.805 --> 00:58:31.605
for, but does anyone know what causes a

00:58:31.605 --> 00:58:34.565
component to enter a different phase? It was

00:58:34.565 --> 00:58:37.445
a word that was brought up yesterday. Yes?

00:58:37.950 --> 00:58:42.190
Yeah, exactly. So, the term that we use

00:58:42.190 --> 00:58:44.350
to describe all the events that cause a

00:58:44.350 --> 00:58:49.630
component to enter a phase is triggers. And

00:58:49.630 --> 00:58:51.390
these are the most common triggers that you're

00:58:51.390 --> 00:58:54.475
gonna see. So the first is whenever you

00:58:54.475 --> 00:58:57.275
open up a website, React is gonna tell

00:58:57.275 --> 00:59:01.675
you to render the root element, which is

00:59:01.675 --> 00:59:04.235
usually app or something, and then it renders

00:59:04.235 --> 00:59:06.700
all of its children, which renders so all

00:59:06.700 --> 00:59:09.500
the components render in the very beginning, and

00:59:09.500 --> 00:59:13.020
that's called the initial render. And that's when

00:59:13.020 --> 00:59:14.620
a trigger is gonna happen because a lot

00:59:14.620 --> 00:59:21.825
of these components are being mounted. And then

00:59:21.825 --> 00:59:24.065
another case is when one of its ancestors

00:59:24.065 --> 00:59:26.465
re renders, and we saw this with form,

00:59:26.705 --> 00:59:29.105
form and button, where button was a child

00:59:29.105 --> 00:59:32.225
of form. Whenever one of your ancestor re

00:59:32.225 --> 00:59:33.745
renders, all of its children are going to

00:59:33.745 --> 00:59:35.530
re render, and all of their children are

00:59:35.530 --> 00:59:38.010
gonna re render. So eventually, if it's your

00:59:38.010 --> 00:59:41.290
ancestor, then you're gonna also re render. Now,

00:59:41.290 --> 00:59:44.890
there are ways of avoiding this. As you

00:59:44.890 --> 00:59:47.625
might suspect, this is pretty expensive. If we

00:59:47.625 --> 00:59:49.465
just wanted to change a state inside the

00:59:49.465 --> 00:59:51.545
app component, that would mean that we would

00:59:51.545 --> 00:59:54.585
have to change all of the children components,

00:59:54.585 --> 00:59:58.265
which seems pretty expensive, not good for responsiveness

00:59:58.265 --> 01:00:00.890
and stuff. So in the future, we'll see

01:00:00.890 --> 01:00:03.930
different callback functions, or sorry, not callback functions,

01:00:03.930 --> 01:00:05.930
different hooks that can be used so that

01:00:05.930 --> 01:00:07.530
we don't have to re render it every

01:00:07.530 --> 01:00:13.765
time an ancestor changes. And the two most

01:00:13.765 --> 01:00:15.845
common things that you'll see, at least in

01:00:15.845 --> 01:00:18.485
the scope of an individual component, is that

01:00:18.485 --> 01:00:20.645
when one of its states changes, it's going

01:00:20.645 --> 01:00:22.885
to rerender. This is going to be a

01:00:22.885 --> 01:00:27.800
trigger for rerendering, as well as when a

01:00:27.800 --> 01:00:30.360
prop that's passed from a parent to the

01:00:30.360 --> 01:00:33.960
child changes, or from a parent to itself

01:00:33.960 --> 01:00:38.600
changes, then it's also gonna rerender. A lot

01:00:38.600 --> 01:00:40.760
of the times, these cases are the same

01:00:40.760 --> 01:00:43.625
because a lot of the times, from parents,

01:00:43.625 --> 01:00:46.345
you're passing down states of the parent as

01:00:46.345 --> 01:00:51.465
props. When the state of a parent changes,

01:00:51.545 --> 01:00:53.545
that causes the parent to rerender, which causes

01:00:53.545 --> 01:00:56.070
you to rerender, which is the same thing

01:00:56.070 --> 01:00:58.630
as when, or it happens at the same

01:00:58.630 --> 01:01:00.710
time as the prop changing because the prop

01:01:00.710 --> 01:01:02.390
was the state that was being passed on.

01:01:06.950 --> 01:01:10.905
Okay. So what's the term for creating the

01:01:10.905 --> 01:01:12.905
virtual DOM at each phase? Does anyone know

01:01:12.905 --> 01:01:19.145
this? I've said it a lot of times

01:01:19.145 --> 01:01:28.830
in the lecture. Like re rendering or rendering.

01:01:28.990 --> 01:01:30.670
I guess the question wasn't too clear, but

01:01:30.670 --> 01:01:35.455
yeah. Rendering is just essentially running the functions

01:01:35.455 --> 01:01:38.255
or running the components and creating all the

01:01:38.255 --> 01:01:45.615
JSX elements that it's comprised of. So, we've

01:01:45.615 --> 01:01:49.380
looked at rendering before, but just again, if

01:01:49.380 --> 01:01:51.860
we have this sort of this is like

01:01:51.860 --> 01:01:56.580
a component tree. If we suppose that a

01:01:56.580 --> 01:02:00.665
state and inspiration generator, this component changes, That's

01:02:00.665 --> 01:02:04.185
a trigger that causes this component to rerender.

01:02:08.185 --> 01:02:10.345
Specifically, we look at the state where or

01:02:10.345 --> 01:02:11.865
we look at the component where the state

01:02:11.865 --> 01:02:15.030
resides. We don't go up all the way

01:02:15.030 --> 01:02:17.190
into the tree to rerender the entire app.

01:02:17.190 --> 01:02:19.910
That's too expensive. So React looks at where

01:02:19.910 --> 01:02:21.750
the state resides so that we can render

01:02:21.750 --> 01:02:26.390
or rerender as little as possible. So we

01:02:26.390 --> 01:02:27.990
look, we see that the state resides in

01:02:27.990 --> 01:02:32.045
Inspiration Generator, And then because its children are

01:02:32.045 --> 01:02:34.205
here, they need to be re rendered as

01:02:34.205 --> 01:02:36.525
well. So that's a trigger for them to

01:02:36.525 --> 01:02:42.845
re render. And yeah, I think we've seen

01:02:42.845 --> 01:02:47.920
this a lot. And last question, there's one

01:02:47.920 --> 01:02:51.200
more keyword for when React transfers the virtual

01:02:51.200 --> 01:02:54.000
DOM to our browser. Does anyone know what

01:02:54.000 --> 01:03:04.275
this is? Close. Serving, yeah. It's similar to

01:03:04.275 --> 01:03:06.915
that. I think it's like the same meaning.

01:03:06.915 --> 01:03:18.140
It's anonymous. Anyone? It's committing. Yeah, so committing

01:03:18.140 --> 01:03:21.340
is just like, essentially it's taking the diff.

01:03:23.795 --> 01:03:27.315
And hopefully this diagram helps. It looks at

01:03:27.315 --> 01:03:29.875
the real DOM, which is owned by the

01:03:29.875 --> 01:03:34.115
browser. So Chrome owns its own DOM, which

01:03:34.115 --> 01:03:37.475
it uses to show the HTML or create

01:03:37.475 --> 01:03:41.100
the HTML. And then React has its virtual

01:03:41.100 --> 01:03:43.740
DOM, and these are like the JSX elements

01:03:43.740 --> 01:03:46.300
or whatever. But you can see them side

01:03:46.300 --> 01:03:52.245
by side and compare them. And during the

01:03:52.245 --> 01:03:54.405
commit step, React will look at the difference

01:03:54.405 --> 01:03:57.765
between these two DOMs and then identify the

01:03:57.765 --> 01:04:01.285
difference or the places where they're different. And

01:04:02.005 --> 01:04:03.925
all of the places where they're different is

01:04:03.925 --> 01:04:10.860
called the diff. And then React is pretty

01:04:10.860 --> 01:04:12.940
smart. It knows that all it has to

01:04:12.940 --> 01:04:14.860
do is only modify the parts where it's

01:04:14.860 --> 01:04:17.820
different, so it's only gonna modify the real

01:04:18.220 --> 01:04:21.835
DOM objects inside the diff to have the

01:04:21.835 --> 01:04:26.475
new updated values. So, if this was the

01:04:26.475 --> 01:04:29.755
old real DOM, the new real DOM will

01:04:29.755 --> 01:04:32.395
just reflect whatever the virtual DOM is, and

01:04:32.395 --> 01:04:36.380
this concludes the last step of React sending

01:04:36.380 --> 01:04:40.860
stuff to the browser, rendering stuff. And then

01:04:40.860 --> 01:04:43.260
once the real DOM changes, there's a last

01:04:43.260 --> 01:04:46.140
step called painting, which the browser does, which

01:04:46.140 --> 01:04:49.580
converts this real DOM to HTML, but that's

01:04:49.580 --> 01:04:57.315
not too important. So the takeaway is that

01:04:57.875 --> 01:05:01.795
we can sort of look at the component's

01:05:01.795 --> 01:05:05.410
life cycle as three phases, mounting, updating, and

01:05:05.410 --> 01:05:09.970
dismounting. And then these transitions are marked by

01:05:09.970 --> 01:05:14.290
three steps. Something happens, which is the trigger,

01:05:14.610 --> 01:05:18.370
which causes the rerender, which creates the React

01:05:18.370 --> 01:05:22.745
DOM, and then React takes the React DOM,

01:05:22.745 --> 01:05:24.745
compares it with the real DOM, and then

01:05:24.745 --> 01:05:27.625
commits the changes essentially to the real DOM.

01:05:28.745 --> 01:05:31.705
So between every transition, we see a trigger,

01:05:31.705 --> 01:05:34.430
render, and commit, But at a broader level,

01:05:34.430 --> 01:05:39.550
we have these three phases. Does that clear

01:05:39.550 --> 01:05:42.270
up some confusions about the life cycle from

01:05:42.270 --> 01:06:02.230
yesterday? Any questions? Okay. And then, really quick

01:06:02.230 --> 01:06:07.910
recap of useEffects. UseEffect takes in two arguments.

01:06:07.910 --> 01:06:10.950
UseEffects, in broad terms, is a hook that

01:06:10.950 --> 01:06:15.875
does something when an event occurs. And we

01:06:15.875 --> 01:06:17.155
usually place that at the top of an

01:06:17.155 --> 01:06:23.475
element underneath useState, but above everything else. But,

01:06:23.475 --> 01:06:25.715
yeah, a useEffect takes two arguments, the first

01:06:25.715 --> 01:06:28.355
being a callback function and the second being

01:06:28.355 --> 01:06:36.380
a dependency array that's optional. And I've changed

01:06:36.380 --> 01:06:41.660
these, like, terminologies here, but hopefully this makes

01:06:41.660 --> 01:06:42.860
more sense now that we know the life

01:06:42.860 --> 01:06:47.185
cycle. But for this useEffects, where we have

01:06:47.185 --> 01:06:49.745
a dependency array of two states, var one

01:06:49.745 --> 01:06:53.185
and var two, this callback function, my function,

01:06:53.185 --> 01:06:55.825
is called on the mount of the component,

01:06:56.545 --> 01:06:59.340
as well as every time the states var

01:06:59.340 --> 01:07:02.540
one and var two change. Essentially, on every

01:07:02.540 --> 01:07:04.780
render or re render where var one and

01:07:04.780 --> 01:07:10.380
var two have changed. And the second use

01:07:10.380 --> 01:07:12.775
of useEffects, where we only want it to

01:07:12.775 --> 01:07:15.655
happen on mounts, is just passing in an

01:07:15.655 --> 01:07:19.415
empty dependency array, which means that this function

01:07:19.415 --> 01:07:21.255
is only called once at the very first

01:07:21.255 --> 01:07:26.460
render. And then if we don't pass in

01:07:26.460 --> 01:07:29.740
any dependency array, this means that this function,

01:07:29.740 --> 01:07:31.660
my function, is gonna be called every time

01:07:31.660 --> 01:07:40.715
the component re renders. Okay. Any questions about

01:07:40.715 --> 01:07:51.000
useEffects? And we'll play around with it. I

01:07:51.000 --> 01:07:55.320
will skip past this. Essentially, useEffects is quite

01:07:55.320 --> 01:07:59.320
useful because suppose that we have a lot

01:07:59.320 --> 01:08:01.400
of complex code that we want to execute

01:08:01.400 --> 01:08:05.425
only once, once a component is mounted, like

01:08:05.425 --> 01:08:08.625
the first time, we could just use useEffects.

01:08:08.625 --> 01:08:11.265
And then what type of dependency array would

01:08:11.265 --> 01:08:12.545
we want to pass it if we want

01:08:12.545 --> 01:08:16.065
it to only happen once upon mount? Anyone?

01:08:26.360 --> 01:08:29.240
Yeah. Exactly. We would use an empty dependency

01:08:29.240 --> 01:08:32.200
array so that all the hard work is

01:08:32.200 --> 01:08:38.215
done only on the first mount. Another reason

01:08:38.215 --> 01:08:41.655
why it's useful is because, as we saw

01:08:41.655 --> 01:08:45.335
in the example from yesterday, like, functions for

01:08:45.335 --> 01:08:49.015
states aren't exactly, like, intuitive because they don't

01:08:49.015 --> 01:08:51.600
happen right after they're called. So if we

01:08:51.600 --> 01:08:55.760
do this, where we append a value to

01:08:55.760 --> 01:08:58.560
the end of an array, the state's not

01:08:58.560 --> 01:09:00.240
actually gonna be updated. It's not gonna have

01:09:00.240 --> 01:09:02.480
me at the end. So the better way

01:09:02.480 --> 01:09:04.080
to do it is have a useEffect that

01:09:04.080 --> 01:09:07.395
takes persons as a dependency and then do

01:09:07.395 --> 01:09:16.355
some functionality with that. Okay. I think I

01:09:16.355 --> 01:09:20.030
can run through this in ten minutes. Okay.

01:09:20.430 --> 01:09:23.790
Hopefully, is helpful, but I wanted to show

01:09:23.790 --> 01:09:25.470
you guys how to create a blank React

01:09:25.470 --> 01:09:27.790
app because you guys have, like, the you

01:09:27.790 --> 01:09:30.110
guys have seen the workshop code, but you

01:09:30.110 --> 01:09:32.510
don't you might not know exactly where it

01:09:32.510 --> 01:09:45.205
came from. And one second. I'm just gonna

01:09:45.205 --> 01:09:57.620
change the screens. Okay. So I'm just gonna

01:09:57.620 --> 01:10:00.100
do it on my end. You don't need

01:10:00.100 --> 01:10:01.940
to follow along. It's probably better if you

01:10:01.940 --> 01:10:03.380
don't follow along so you can actually see

01:10:03.380 --> 01:10:05.725
what's going on. But I'm gonna create a

01:10:05.725 --> 01:10:08.365
blank react app and then implement a stopwatch

01:10:08.525 --> 01:10:10.845
that looks like this, where we can toggle

01:10:10.845 --> 01:10:14.205
the clock and then the time just runs

01:10:14.445 --> 01:10:19.100
every one second and increments. And this will

01:10:19.100 --> 01:10:21.260
use use state, use effects, everything that we

01:10:21.260 --> 01:10:25.660
learn. So in my terminal, I'm just gonna

01:10:25.660 --> 01:10:40.565
create or run the commands. Sorry. One second.

01:10:51.190 --> 01:11:06.765
Okay. I'm here. Okay. There we go. So

01:11:06.765 --> 01:11:10.685
in my terminal, I'm gonna run npm creates

01:11:10.685 --> 01:11:32.995
veets at latest. Oh. Okay. Can you guys

01:11:32.995 --> 01:11:37.955
see it? Okay. So in some random directory,

01:11:37.955 --> 01:11:41.635
I'm running npm create v at latest. V

01:11:41.635 --> 01:11:46.600
helps us create React apps. Project name, I'm

01:11:46.600 --> 01:11:49.800
just gonna call it test two. Select a

01:11:49.800 --> 01:11:54.120
framework, I wanna use React. I'll use a

01:11:54.120 --> 01:12:00.255
standard JavaScript React project. And then now, if

01:12:00.255 --> 01:12:03.295
I look at my directory, see test two.

01:12:03.295 --> 01:12:08.895
So I'm gonna change directory into it. I

01:12:08.895 --> 01:12:10.495
see that it's populated with a lot of

01:12:10.495 --> 01:12:15.170
files. That's great. And then I'm just gonna

01:12:15.170 --> 01:12:24.130
open up up the the code now. You

01:12:24.130 --> 01:12:28.945
guys see that? Okay. So I'll open up

01:12:28.945 --> 01:12:32.225
a terminal. First step, whenever you create a

01:12:32.225 --> 01:12:35.025
new project, is to run npm install. You

01:12:35.025 --> 01:12:38.065
guys already did that with Catbook, so you

01:12:38.065 --> 01:12:39.505
probably don't need to for a long time.

01:12:43.690 --> 01:12:47.930
In the meantime, I'm gonna open up app

01:12:47.930 --> 01:12:54.545
dot jsx and main dot jsx. And what's

01:12:54.545 --> 01:12:57.985
really important to see is that in main,

01:12:58.865 --> 01:13:02.705
actually even higher up, I'm gonna go to

01:13:02.705 --> 01:13:06.865
index dot html. So any time you create

01:13:06.865 --> 01:13:09.870
a React app, essentially it's serving an HTML

01:13:09.870 --> 01:13:11.950
file as well as lots of JavaScript files

01:13:11.950 --> 01:13:15.230
to define, like, how to, like, manipulate that

01:13:15.230 --> 01:13:19.950
HTML file. And it's so abstracted that the

01:13:19.950 --> 01:13:22.430
only JavaScript file we're passing is main dot

01:13:22.430 --> 01:13:27.115
JSX into this HTML file. Now that I've

01:13:27.115 --> 01:13:31.995
installed, I'm gonna run npm run dev. And

01:13:31.995 --> 01:13:38.960
then in my local host 5173, I should

01:13:38.960 --> 01:13:42.080
be able to see this blank react app.

01:13:45.280 --> 01:13:47.600
But, yeah. So if I right click here

01:13:48.080 --> 01:13:51.995
and then look at the HTML, I can

01:13:51.995 --> 01:13:53.755
actually see that this is the same exact

01:13:53.755 --> 01:13:57.035
index dot HTML that I'm sending over that

01:13:57.035 --> 01:13:59.115
I have in my code base here. And

01:13:59.115 --> 01:14:01.835
it has the same source equals source main

01:14:01.835 --> 01:14:04.620
dot j s x. This tells us that

01:14:04.620 --> 01:14:09.100
all of the React logic is being somehow

01:14:09.260 --> 01:14:11.340
taken from main dot jsx and then put

01:14:11.340 --> 01:14:16.795
into this HTML file. So how exactly is

01:14:16.795 --> 01:14:20.075
it doing it? It's taking or React takes

01:14:20.075 --> 01:14:23.835
the document and then finds the ID or

01:14:23.835 --> 01:14:27.035
the element with the ID root. And if

01:14:27.035 --> 01:14:31.130
we look here in the HTML here, the

01:14:31.130 --> 01:14:35.450
div that's like the innermost div for body

01:14:35.770 --> 01:14:38.490
is actually the one with ID root. So

01:14:38.490 --> 01:14:42.410
what that means is React is creating a

01:14:42.410 --> 01:14:46.375
root within that div by finding the div

01:14:46.855 --> 01:14:51.575
and then rendering the app component. So this

01:14:51.575 --> 01:14:53.975
is the connection point between React and HTML.

01:14:58.660 --> 01:15:00.180
You don't actually have to deal with this

01:15:00.180 --> 01:15:03.620
a lot or actually ever. Once you know

01:15:03.620 --> 01:15:08.500
this, you can comfortably understand like, okay, I

01:15:08.500 --> 01:15:10.020
know that my app is being rendered so

01:15:10.020 --> 01:15:11.220
all I have to do is change how

01:15:11.220 --> 01:15:13.155
app is implemented and then I can render

01:15:13.155 --> 01:15:16.435
whatever whatever I want on the website. So

01:15:16.435 --> 01:15:19.315
that's what's happening right now. We have all

01:15:19.315 --> 01:15:22.515
this code here that I'm just gonna get

01:15:22.515 --> 01:15:25.075
rid of. I'm also gonna get rid of

01:15:25.075 --> 01:15:29.700
the CSS. I'm gonna create a very simple

01:15:29.700 --> 01:15:35.060
timer, and I'll just put it inside app.

01:15:35.540 --> 01:15:37.940
First step is gonna be having a time

01:15:37.940 --> 01:15:46.935
state. Sorry. Maybe I shouldn't do this. Let

01:15:46.935 --> 01:15:50.215
me create a new file called stopwatch dot

01:15:50.215 --> 01:15:54.055
JSX. Inside here, to define a component, I

01:15:54.055 --> 01:16:00.670
just say const stopwatch equals a callback function.

01:16:02.270 --> 01:16:05.150
Inside this callback function, I'm going to have

01:16:05.150 --> 01:16:10.030
some JSX. And then at the end of

01:16:10.030 --> 01:16:13.765
the file, I have to export default stopwatch.

01:16:17.685 --> 01:16:21.845
Sorry. This is so fast. But here, to

01:16:21.845 --> 01:16:26.085
render stopwatch, I'm just gonna go import stopwatch

01:16:26.405 --> 01:16:31.300
from the same directory and then I'm gonna

01:16:31.300 --> 01:16:38.180
return stopwatch. Okay. So if I refresh this

01:16:38.180 --> 01:16:40.980
page now, I see hi, which is great.

01:16:41.460 --> 01:16:45.305
Let me get rid of this this CSS

01:16:45.305 --> 01:16:53.865
inside main. But yeah. What I eventually want

01:16:53.865 --> 01:16:57.545
is this. I won't implement the toggle for

01:16:57.545 --> 01:17:00.130
now. I'm just gonna implement the stop watch.

01:17:03.330 --> 01:17:04.930
And the first step is to create a

01:17:04.930 --> 01:17:07.170
state for the time because this time is

01:17:07.170 --> 01:17:13.745
gonna be displayed to the UI. So const

01:17:13.745 --> 01:17:19.265
time set time equals use state and then

01:17:19.265 --> 01:17:21.905
the initial value is zero, so I put

01:17:21.905 --> 01:17:25.890
a zero here. It's yelling at me because

01:17:25.890 --> 01:17:27.570
it doesn't know what use state is, so

01:17:27.570 --> 01:17:31.250
import use state. And then I always just

01:17:31.250 --> 01:17:33.410
press the first option because it usually does

01:17:33.410 --> 01:17:38.495
it fine. So what I want to happen

01:17:38.495 --> 01:17:42.815
is on the first render, it starts incrementing

01:17:42.815 --> 01:17:44.895
the time. Now there's two ways to do

01:17:44.895 --> 01:17:46.335
this and I'll show you the fast way

01:17:46.335 --> 01:17:50.810
to do it. I'm gonna use the use

01:17:50.810 --> 01:17:54.970
effects or first off, let me just like

01:17:54.970 --> 01:18:01.370
render time. If you yeah. You see here

01:18:01.370 --> 01:18:03.130
it's just always gonna be zero because we're

01:18:03.130 --> 01:18:06.795
not actually setting it. But now, let's create

01:18:06.795 --> 01:18:10.475
a useEffects. So the first argument is a

01:18:10.475 --> 01:18:15.435
callback function. And the second argument is a

01:18:15.435 --> 01:18:27.410
dependency array. I'll import useEffects. Oh, thanks. Yeah.

01:18:44.300 --> 01:18:48.860
Okay. So, yeah. I set I have the

01:18:48.860 --> 01:18:51.020
use effects and I'm gonna use time as

01:18:51.020 --> 01:18:56.060
the dependency. And this is a function that

01:18:56.060 --> 01:18:57.900
you haven't seen before, it's or you probably

01:18:57.900 --> 01:19:01.325
haven't seen before. It's set interval and it

01:19:01.325 --> 01:19:05.645
takes in a callback as well as a

01:19:05.645 --> 01:19:08.925
time. And essentially all it does is like

01:19:08.925 --> 01:19:11.725
it runs this callback after this number of

01:19:11.725 --> 01:19:14.950
milliseconds. So inside here, if I did like

01:19:14.950 --> 01:19:16.870
console dot log hi or whatever, it would

01:19:16.870 --> 01:19:19.110
like print this after a thousand milliseconds or

01:19:19.110 --> 01:19:23.190
one second. Yeah, inside of the set interval,

01:19:23.350 --> 01:19:27.485
I want to somehow update my time or

01:19:27.485 --> 01:19:30.125
increment my time. And to do that, I

01:19:30.125 --> 01:19:31.565
have to use my set time. I can't

01:19:31.565 --> 01:19:35.805
just do time plus plus or something. I

01:19:35.805 --> 01:19:38.605
do set time and then time plus one

01:19:39.330 --> 01:19:42.210
because I take the old value, add one

01:19:42.210 --> 01:19:44.610
to it, and then set that to be

01:19:44.610 --> 01:19:49.490
the new state value. If I do this

01:19:49.490 --> 01:19:55.635
now, the timer is working fine. To explain

01:19:55.635 --> 01:19:58.275
what this is doing again, I have a

01:19:58.275 --> 01:20:01.235
state that's initialized to zero. So when I

01:20:01.235 --> 01:20:03.155
refresh the page, it's gonna start at zero.

01:20:04.790 --> 01:20:08.070
And then every time time is changed, as

01:20:08.070 --> 01:20:10.310
well as on the first mount or the

01:20:10.310 --> 01:20:16.805
first render, this callback function is run. This

01:20:16.805 --> 01:20:21.445
callback function runs, or calls set interval, which

01:20:22.165 --> 01:20:27.285
after one second runs this callback function, which

01:20:27.285 --> 01:20:29.925
sets the time to one more than it

01:20:29.925 --> 01:20:33.280
used to be. So on the first render,

01:20:33.280 --> 01:20:36.080
time is gonna be zero. It's going to

01:20:36.080 --> 01:20:38.880
run this callback function immediately because it just

01:20:38.880 --> 01:20:42.080
mounted. And then it's gonna wait one second

01:20:42.240 --> 01:20:44.880
and then set time to zero plus one

01:20:44.880 --> 01:20:48.305
or one. And at that point, because time

01:20:48.305 --> 01:20:52.705
has changed to one now, the component's gonna

01:20:52.705 --> 01:20:55.265
rerender because one of its states has changed.

01:20:55.745 --> 01:20:58.305
And the useEffect sees that one of its

01:20:58.305 --> 01:21:00.465
dependencies time has changed from zero to one,

01:21:01.370 --> 01:21:06.970
which then runs its callback function again. And

01:21:06.970 --> 01:21:09.530
then it sets time to two, and then

01:21:09.530 --> 01:21:10.970
it sees the time has changed again, so

01:21:10.970 --> 01:21:12.970
it sets time to three, and so on.

01:21:13.210 --> 01:21:15.690
Every time with a thousand milliseconds between it,

01:21:17.985 --> 01:21:22.225
Which is why, yeah, which is why we

01:21:22.225 --> 01:21:25.185
see the timer commencing by one every one

01:21:25.185 --> 01:21:30.705
second. Okay. I've run over. Any questions about

01:21:30.705 --> 01:21:41.000
this though? Okay. Cool. I guess I don't

01:21:41.000 --> 01:21:45.485
have a slide for it, but you can

01:21:45.485 --> 01:21:48.125
look at the completed code here. This uses

01:21:48.125 --> 01:21:52.045
a different implementation. And you can also read

01:21:52.045 --> 01:21:54.685
the recap. Guess this entire lecture was a

01:21:54.685 --> 01:21:58.734
recap. Yeah. If you wanna fill out weblab.

01:21:58.734 --> 01:22:01.934
Isfeedback, that'd be great and then we'll get

01:22:01.934 --> 01:22:03.294
started with workshop two.
