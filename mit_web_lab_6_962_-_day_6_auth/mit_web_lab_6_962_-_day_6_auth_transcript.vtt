WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 84ae0075-c2aa-4064-9435-20ce1c86dd59
Created: 2025-05-16T01:59:56.363Z
Duration: 2005.0808
Channels: 1

00:00:00.640 --> 00:00:02.960
Okay. Hi, everyone. Hope you're having a great

00:00:02.960 --> 00:00:06.240
Monday. So me and Sophie are going to

00:00:06.240 --> 00:00:09.280
be talking about auth today, and it's kind

00:00:09.280 --> 00:00:12.560
of a really meaty lesson and workshop. So

00:00:12.640 --> 00:00:14.400
don't worry if you guys feel a little

00:00:14.640 --> 00:00:19.205
oh, can you mute my thing? Yeah. Don't

00:00:19.205 --> 00:00:21.205
worry if you guys feel a little confused.

00:00:23.365 --> 00:00:25.925
But yeah. So I'm gonna talk about some

00:00:25.925 --> 00:00:27.925
intro first before we actually get into the

00:00:27.925 --> 00:00:30.370
workshop. So hopefully you guys can understand things

00:00:30.370 --> 00:00:33.330
conceptually a little better. When we refer to

00:00:33.330 --> 00:00:35.330
auth, we are gonna be talking about both

00:00:35.330 --> 00:00:39.010
authorization and authentication. And we're gonna talk about

00:00:39.010 --> 00:00:41.330
like what the differences between those are as

00:00:41.330 --> 00:00:44.725
well in the introduction. So you can see

00:00:44.725 --> 00:00:47.525
here on Abby's Facebook, right, if we're having

00:00:47.525 --> 00:00:49.525
like like our cat book for example, we

00:00:49.525 --> 00:00:51.605
want users to be able to know who

00:00:51.605 --> 00:00:53.605
they are when they're logged in and also

00:00:53.605 --> 00:00:56.645
like what stories and comments correspond to their

00:00:56.645 --> 00:00:59.310
profile specifically. So with Facebook, how do we

00:00:59.310 --> 00:01:02.590
know that, like, Kaylee Mary posted this meme,

00:01:02.590 --> 00:01:04.910
for example, and, like, Abby it's on Abby's

00:01:04.910 --> 00:01:07.150
profile, and she's the one currently logged in.

00:01:07.550 --> 00:01:10.205
So authentication deals with how we are proving

00:01:10.205 --> 00:01:12.845
our identity to a website. It's basically the

00:01:12.845 --> 00:01:15.085
website saying like, hey, this user is who

00:01:15.085 --> 00:01:17.245
they claim to be and like this is

00:01:17.245 --> 00:01:19.805
all the information that falls under that user's

00:01:20.125 --> 00:01:24.330
login stuff. So when the client is sending

00:01:24.330 --> 00:01:26.410
a post request and pinging the login API

00:01:26.410 --> 00:01:28.490
endpoint, our server needs to be able to

00:01:28.490 --> 00:01:31.610
find the user's information within MongoDB in a

00:01:31.610 --> 00:01:35.610
stored database of users by checking if it

00:01:35.610 --> 00:01:37.690
has the credentials that the user is claiming

00:01:37.690 --> 00:01:40.405
to have. So one way that we can

00:01:40.405 --> 00:01:43.125
store username and password information is by just

00:01:43.125 --> 00:01:45.445
creating a user schema in our database. So

00:01:45.445 --> 00:01:47.205
if you guys remember from the database lecture

00:01:47.205 --> 00:01:49.045
that Sophie and I gave, we talked about

00:01:49.045 --> 00:01:51.445
how schemas are ways that we can enforce

00:01:51.445 --> 00:01:54.500
structures onto documents. So do you think that

00:01:54.500 --> 00:01:56.180
it's feasible for us to just create a

00:01:56.180 --> 00:01:58.740
user schema like this with fields like name,

00:01:58.740 --> 00:02:01.300
email, password, and store them as strings within

00:02:01.300 --> 00:02:03.700
our database? Give me a thumbs up if

00:02:03.700 --> 00:02:06.020
you think this is a good proposal and

00:02:06.020 --> 00:02:11.565
thumbs down if you think no. Okay. I'm

00:02:11.565 --> 00:02:13.965
seeing some mixed, but yeah, the majority is

00:02:13.965 --> 00:02:16.205
thumbs down and they'd be you'd be exactly

00:02:16.205 --> 00:02:18.925
correct because the password is not encrypted at

00:02:18.925 --> 00:02:22.125
all. Right? So having developer access to all

00:02:22.125 --> 00:02:24.590
of the passwords of users platform like this

00:02:24.590 --> 00:02:26.990
is extremely bad because it can very easily

00:02:26.990 --> 00:02:30.670
get leaked and then hackers can very easily

00:02:30.670 --> 00:02:32.510
access it. And most of the time, you

00:02:32.510 --> 00:02:34.510
guys probably use like the same password across

00:02:34.510 --> 00:02:37.230
multiple different applications. So you're not just like

00:02:37.230 --> 00:02:39.150
leaking the password for this one application, you're

00:02:39.150 --> 00:02:41.445
leaking the password for like probably like, I

00:02:41.445 --> 00:02:44.005
don't know, your entire what's the word I'm

00:02:44.005 --> 00:02:48.885
looking for? Net worth. Yeah. Okay. So we

00:02:48.885 --> 00:02:51.445
have one potential solution which is using hash

00:02:51.445 --> 00:02:54.830
functions. Hash functions basically just take in a

00:02:54.830 --> 00:02:56.990
string like this, and they'll use a mathematical

00:02:56.990 --> 00:03:01.470
function to generate, like, a crypt encrypted string

00:03:01.470 --> 00:03:04.670
as an output. Hash functions are one way,

00:03:04.670 --> 00:03:06.750
so our output hash doesn't tell us anything

00:03:06.750 --> 00:03:08.670
about what we actually inputted to the function.

00:03:08.925 --> 00:03:11.405
And they're also deterministic, which means the same

00:03:11.405 --> 00:03:14.045
input gives you the same output hash values,

00:03:14.045 --> 00:03:15.565
which is nice. Right? You might think like,

00:03:15.565 --> 00:03:17.805
wow, now we can just store our passwords

00:03:17.965 --> 00:03:20.125
after running them through this hash function because

00:03:20.125 --> 00:03:22.765
now they're like these encrypted strings. So this

00:03:22.765 --> 00:03:24.045
might be better. Right? What do you guys

00:03:24.045 --> 00:03:26.340
think? Like, thumbs up for better solution or

00:03:26.340 --> 00:03:31.380
thumbs down for no? Okay. I'm still seeing

00:03:31.380 --> 00:03:33.380
some thumbs down and you would be correct

00:03:33.380 --> 00:03:36.180
again. Because one of the things we actually

00:03:36.180 --> 00:03:38.645
have is like online, you can just look

00:03:38.645 --> 00:03:41.285
up the hashes that correspond to some of

00:03:41.285 --> 00:03:44.245
the really common passwords that people use. So

00:03:44.725 --> 00:03:47.285
you can, like, very easily kind of, like,

00:03:47.285 --> 00:03:50.005
guess a lot of different passwords and see

00:03:50.005 --> 00:03:52.530
the corresponding hash functions that already exist. And

00:03:52.530 --> 00:03:54.530
like, if someone's testing like a million passwords

00:03:54.530 --> 00:03:56.210
a minute, they can like probably get it

00:03:56.210 --> 00:04:00.290
within like a few hours. Right? So it's

00:04:00.290 --> 00:04:01.970
still not that secure. Okay. So we have

00:04:01.970 --> 00:04:03.570
like another option, is we can do something

00:04:03.570 --> 00:04:06.215
called password hash salting, where we add a

00:04:06.215 --> 00:04:08.375
salt to our hash function, which is just

00:04:08.375 --> 00:04:11.015
like another kind of like ran it's just

00:04:11.015 --> 00:04:13.175
like more data that we're adding to our

00:04:13.175 --> 00:04:14.935
initial input to the hash function. So it

00:04:14.935 --> 00:04:16.535
makes it like a little more secure because

00:04:16.535 --> 00:04:18.535
these salts are pretty hard to decrypt and

00:04:20.040 --> 00:04:22.360
like, it makes it diff more difficult for

00:04:22.360 --> 00:04:25.400
hackers to decrypt it. But I'm not gonna

00:04:25.400 --> 00:04:27.480
go into the details of what, like, salting

00:04:27.480 --> 00:04:29.480
actually looks like, but it's basically just adding

00:04:29.480 --> 00:04:31.320
a lot of, like, random data to our

00:04:31.320 --> 00:04:32.920
string to begin with, so it becomes a

00:04:32.920 --> 00:04:35.815
little more secure. But this is still not

00:04:35.815 --> 00:04:39.575
that secure because, again, like we talked about

00:04:39.575 --> 00:04:42.935
before, right, the passwords are not rate limited.

00:04:42.935 --> 00:04:45.655
So someone can just be testing as many

00:04:45.655 --> 00:04:47.575
passwords as they can possibly test in a

00:04:47.575 --> 00:04:49.650
given time frame. And at some point, they're

00:04:49.650 --> 00:04:51.410
most likely going to be able to get

00:04:51.410 --> 00:04:54.770
the correct password. Right? So the conclusion for

00:04:54.770 --> 00:04:56.690
all of this long tangent was just that

00:04:56.690 --> 00:04:59.250
storing passwords is really difficult. So instead of

00:04:59.250 --> 00:05:01.615
like having to store passwords by ourselves on

00:05:01.615 --> 00:05:03.455
our web applications, we're just going to make

00:05:03.455 --> 00:05:05.295
it easier for us and use Google. So

00:05:05.295 --> 00:05:08.895
Google has this really nice authentication setup that

00:05:08.895 --> 00:05:11.295
they have already created, and we are just

00:05:11.295 --> 00:05:12.975
going to take advantage of this for our

00:05:12.975 --> 00:05:15.730
own purposes. So you guys probably are very

00:05:15.730 --> 00:05:18.770
familiar with the login with Google button that's

00:05:19.410 --> 00:05:22.850
on, like, probably, like most pages these days.

00:05:24.130 --> 00:05:26.050
And so, for example, if I'm trying to

00:05:26.050 --> 00:05:28.625
sign in to MongoDB, right, I can choose

00:05:28.625 --> 00:05:30.625
an account to log in. But you might

00:05:30.625 --> 00:05:32.465
be thinking like, this is pretty interesting, right,

00:05:32.465 --> 00:05:35.585
because we're signing into MongoDB, but we're seeing

00:05:35.585 --> 00:05:40.945
like the the Google URL. But MongoDB has

00:05:40.945 --> 00:05:42.625
nothing to do with Google. So how does

00:05:42.625 --> 00:05:45.510
MongoDB get the information from Google that we've

00:05:45.510 --> 00:05:47.430
successfully logged in and prove that we are

00:05:47.430 --> 00:05:49.910
who we say we are? So how does

00:05:49.910 --> 00:05:52.310
a website know that we've logged into Google?

00:05:53.030 --> 00:05:56.150
So for example, on Piazza, this is another

00:05:56.150 --> 00:05:57.510
kind of issue that we need to take

00:05:57.510 --> 00:06:00.230
into consideration, is that if I do log

00:05:59.805 --> 00:06:02.125
in and say that I'm, like, me, right,

00:06:02.445 --> 00:06:03.805
the other thing is, like, I'm logged in

00:06:03.805 --> 00:06:05.805
as an instructor, so I should have instructor

00:06:05.805 --> 00:06:07.725
permissions, which means I should be able to,

00:06:07.725 --> 00:06:10.045
like, post things as an instructor. So besides

00:06:10.045 --> 00:06:11.885
just proving to the website that we are

00:06:11.885 --> 00:06:13.805
who we say we are, we also should

00:06:13.805 --> 00:06:16.610
get specific permissions or things granted to us

00:06:16.610 --> 00:06:18.690
if we have different roles on that website.

00:06:18.690 --> 00:06:20.690
So like a student dashboard should look different

00:06:20.690 --> 00:06:23.010
from an instructor dashboard. This is also like

00:06:23.010 --> 00:06:25.250
a pub to fill out the food thoughts

00:06:25.250 --> 00:06:30.635
post because no one responded. Yeah. So currently,

00:06:30.635 --> 00:06:32.875
right, like basically what we're looking at is

00:06:32.875 --> 00:06:35.115
we have like a user sending a post

00:06:35.115 --> 00:06:37.915
request to our login API endpoint with their

00:06:37.915 --> 00:06:42.210
username and password information. But let's and then

00:06:42.210 --> 00:06:45.730
the server should send back the information that

00:06:45.730 --> 00:06:47.810
the user should see on their front end.

00:06:48.610 --> 00:06:50.210
But let's say we have, like, a lot

00:06:50.210 --> 00:06:53.010
of different machines sending this request at once,

00:06:53.010 --> 00:06:55.090
and they're all pinging the API login endpoint.

00:06:56.145 --> 00:06:59.345
How do we know that, like, Sophie's pinging

00:06:59.345 --> 00:07:01.825
the API login endpoint and, like, sending a

00:07:01.825 --> 00:07:03.905
GET request to fetch all of her stories

00:07:03.905 --> 00:07:06.225
is different than, like, Arando pinging the same

00:07:06.225 --> 00:07:09.185
endpoint? Like, how does the server tell who's,

00:07:09.185 --> 00:07:12.990
like, who's making that GET request? Well, one

00:07:12.990 --> 00:07:14.990
of the things we can try is, let's

00:07:14.990 --> 00:07:17.550
say we just send the username of the

00:07:17.550 --> 00:07:19.870
person that's logged in in the query parameters

00:07:19.870 --> 00:07:22.270
of the GET request. Do you guys think

00:07:22.270 --> 00:07:24.245
that this would work server to be able

00:07:24.245 --> 00:07:26.725
to differentiate who is logged in and, like,

00:07:26.725 --> 00:07:30.245
accurately recognize them? Thumbs up for yes, thumbs

00:07:30.245 --> 00:07:34.005
down for no. Yeah. I'm seeing a lot

00:07:34.005 --> 00:07:37.765
of thumbs down, which is correct. Because query

00:07:37.765 --> 00:07:39.950
parameters like this can very, very easily be

00:07:39.950 --> 00:07:41.710
changed. Right? Like, you can just literally go

00:07:41.710 --> 00:07:43.710
into the query parameters and, like, delete it.

00:07:43.710 --> 00:07:45.630
So I can just write, like, username equals

00:07:45.630 --> 00:07:48.270
Sophie, and then I would, like, be Sophie.

00:07:48.270 --> 00:07:51.550
But that's not what we want. Right? So

00:07:51.550 --> 00:07:53.630
let's modify this proposal a bit. What if

00:07:53.630 --> 00:07:55.585
instead of looking at the query parameters, we

00:07:55.585 --> 00:07:57.585
look at the IP address of who's sending

00:07:57.585 --> 00:08:00.225
it? So we say like, oh, Sophie is

00:08:00.225 --> 00:08:02.705
sending this GET request and then the Rando

00:08:02.705 --> 00:08:04.065
is sending the other GET request. Can we

00:08:04.065 --> 00:08:06.545
use that to differentiate who is actually logged

00:08:06.545 --> 00:08:08.465
in? Thumbs up for yes, thumbs down for

00:08:08.465 --> 00:08:12.100
no. Yeah. I'm still seeing a lot of

00:08:12.100 --> 00:08:14.500
thumbs down, which is correct because IP addresses

00:08:14.500 --> 00:08:16.260
are not secure because they can very easily

00:08:16.260 --> 00:08:18.740
be spoofed by hackers. So we can't use

00:08:18.740 --> 00:08:20.580
the IP address to differentiate who is logged

00:08:20.580 --> 00:08:23.860
in either. The conclusion of this second long

00:08:23.860 --> 00:08:25.945
tangent is that we can never really trust

00:08:25.945 --> 00:08:27.705
the client. So no matter what the client

00:08:27.705 --> 00:08:29.625
says, it's very easy for them to just

00:08:29.625 --> 00:08:31.545
lie about who they say they are by

00:08:31.545 --> 00:08:33.625
either faking the query parameters or spoofing their

00:08:33.625 --> 00:08:37.065
IP address. So we can have this normal

00:08:37.065 --> 00:08:38.905
mongoose saying they're Sophie. We can also have

00:08:38.905 --> 00:08:41.630
a malicious mongoose hacker saying they're Sophie. And

00:08:41.630 --> 00:08:43.390
there's no way to really differentiate these if

00:08:43.390 --> 00:08:45.950
we trust the client. So to recap what

00:08:45.950 --> 00:08:47.630
we've talked about so far, if we log

00:08:47.630 --> 00:08:49.790
into a website with Google or using some

00:08:49.790 --> 00:08:52.350
other third party authentication service, you guys have

00:08:52.350 --> 00:08:55.150
probably heard of other authentication platforms, like MIT

00:08:55.150 --> 00:08:58.345
uses Okta. How are we proving to this

00:08:58.345 --> 00:09:00.345
website that we've logged into Google or this

00:09:00.345 --> 00:09:03.305
other authentication platform? And once we've actually logged

00:09:03.305 --> 00:09:05.865
in and we continue making GET requests, for

00:09:05.865 --> 00:09:09.225
example, how does the website know that we've

00:09:09.225 --> 00:09:12.830
already logged in and can show us different

00:09:12.830 --> 00:09:14.830
permissions based on who we say we are?

00:09:15.470 --> 00:09:16.910
And we want to do all of this

00:09:16.910 --> 00:09:19.070
without trusting the client because we all saw

00:09:19.070 --> 00:09:22.350
how that turned out. Not great. Right? So

00:09:22.350 --> 00:09:24.830
we have these really cool things called sessions

00:09:25.425 --> 00:09:29.745
and tokens. Okay. So let's talk about sessions

00:09:29.745 --> 00:09:33.985
first. So what sessions do essentially is now

00:09:33.985 --> 00:09:35.585
when a user is logging in, they're going

00:09:35.585 --> 00:09:37.905
to send their credentials over to the server.

00:09:38.580 --> 00:09:40.580
And the server is going to store all

00:09:40.580 --> 00:09:43.300
of the user's information in something called, like,

00:09:43.300 --> 00:09:46.420
a global session lookup table. Essentially, it's just

00:09:46.420 --> 00:09:49.540
this table that is globally accessible, and it'll

00:09:49.540 --> 00:09:52.900
have information with a session ID corresponding to

00:09:52.900 --> 00:09:55.165
all of the user's information. So like here,

00:09:55.165 --> 00:09:56.685
you see like my username and my user

00:09:56.685 --> 00:09:59.165
ID and I have this uniquely generated session

00:09:59.165 --> 00:10:02.445
ID. Now what the server is gonna do

00:10:02.445 --> 00:10:04.205
is it's gonna send a response to the

00:10:04.205 --> 00:10:07.485
client with the uniquely generated session ID for

00:10:07.485 --> 00:10:11.240
that specific client. And the client is going

00:10:11.240 --> 00:10:13.640
to use that session ID and send it

00:10:13.640 --> 00:10:16.040
back to the session when making future not

00:10:16.040 --> 00:10:17.880
session, send it back to the server when

00:10:17.880 --> 00:10:22.600
making future requests. So anytime the client pings

00:10:22.600 --> 00:10:24.440
the like makes a GET request in the

00:10:24.440 --> 00:10:27.375
future, they're gonna send this session ID back

00:10:27.375 --> 00:10:28.975
in the form of a cookie. And then

00:10:28.975 --> 00:10:30.735
the server is going to be able to

00:10:30.735 --> 00:10:32.895
send a response back corresponding to that user

00:10:32.895 --> 00:10:38.280
specific unique session ID. Okay. Why do you

00:10:38.280 --> 00:10:40.440
guys think that sessions can solve the problem

00:10:40.440 --> 00:10:42.440
of verifying that we're actually logged in? Turn

00:10:42.440 --> 00:10:44.920
and talk to a neighbor. Like, how does

00:10:44.920 --> 00:10:46.680
this solve all the dilemmas that we just

00:10:46.680 --> 00:10:48.680
talked about earlier? What do you guys think?

00:10:48.680 --> 00:12:22.975
Give you, like, thirty seconds. Okay. Hopefully you

00:12:22.975 --> 00:12:25.215
guys had time to think about it. But

00:12:25.215 --> 00:12:28.120
does anyone want to take a stab at

00:12:28.360 --> 00:12:41.365
how sessions solve the problem for us? Okay.

00:12:41.365 --> 00:12:47.365
It's okay. I understand. But basically, right, so

00:12:47.365 --> 00:12:50.645
sessions remember when we like, we're looking at

00:12:50.645 --> 00:12:52.965
the diagram previously, we saw that the server

00:12:52.965 --> 00:12:55.590
was storing all of the user's information on

00:12:55.590 --> 00:12:57.750
the server side. Right? So all of the

00:12:57.750 --> 00:13:00.470
user information is being stored securely by the

00:13:00.470 --> 00:13:03.430
server, like stuff like username, right, user ID,

00:13:03.510 --> 00:13:05.590
and the only thing that the client is

00:13:05.590 --> 00:13:07.830
actually getting is the session ID that was

00:13:07.830 --> 00:13:10.070
generated by the server, and they're just sending

00:13:10.070 --> 00:13:11.455
it back in the form of a cookie

00:13:11.455 --> 00:13:14.815
on future requests. So now all the sensitive

00:13:14.815 --> 00:13:17.615
information is stored securely on the server instead

00:13:17.615 --> 00:13:19.935
of having the client send their information and

00:13:19.935 --> 00:13:23.230
their credentials back to the server. So this

00:13:23.230 --> 00:13:25.230
is more secure, right, because we can see

00:13:25.230 --> 00:13:27.230
that instead of the scenarios we were describing

00:13:27.230 --> 00:13:30.750
previously, where the client can just modify their

00:13:31.150 --> 00:13:33.870
query parameters or modify their IP address, now

00:13:33.870 --> 00:13:35.870
the server is securely storing all of the

00:13:35.870 --> 00:13:37.950
information about a user. And the only thing

00:13:37.950 --> 00:13:40.935
that the user is getting is the session

00:13:40.935 --> 00:13:43.095
ID, which they're gonna send back in the

00:13:43.095 --> 00:13:47.095
form of a cookie on future requests. So

00:13:47.095 --> 00:13:49.175
our session is stored on server on our

00:13:49.175 --> 00:13:50.695
server. This is kinda like the key point

00:13:50.695 --> 00:13:53.095
of sessions. But there's a couple of issues

00:13:53.095 --> 00:13:56.900
with this too. Let's say we have multiple

00:13:56.900 --> 00:14:00.100
different servers. Right? Can you guys, like, think

00:14:00.100 --> 00:14:02.020
for, like, twenty seconds about, like, what's one

00:14:02.020 --> 00:14:04.340
potential problem that we might have if we

00:14:04.340 --> 00:14:06.900
use sessions and we're running, like, multiple different

00:14:06.900 --> 00:14:11.385
servers? Feel free to talk with each other

00:14:11.385 --> 00:14:42.755
also. Okay. So yeah. When storing data on

00:14:42.755 --> 00:14:45.395
multiple different servers, you can imagine that each

00:14:45.395 --> 00:14:48.670
server now needs to store its own global

00:14:48.670 --> 00:14:51.230
lookup table for the session IDs. Right? And

00:14:51.230 --> 00:14:52.670
so this can get kind of messy because

00:14:52.670 --> 00:14:54.670
now we have like five different servers with

00:14:54.670 --> 00:14:57.230
five different global lookup tables and like so

00:14:57.230 --> 00:14:59.550
many users using our platform, it can get

00:14:59.550 --> 00:15:01.735
kind of messy. So sessions run into the

00:15:01.735 --> 00:15:04.055
issue of scalability, and it can be kind

00:15:04.055 --> 00:15:05.735
of difficult to translate when you're trying to

00:15:05.735 --> 00:15:09.095
run multiple servers at once. But besides that,

00:15:09.095 --> 00:15:11.015
sessions are still useful. So we're not saying

00:15:11.015 --> 00:15:12.535
sessions are bad, we're just saying like this

00:15:12.535 --> 00:15:14.375
is one of the cons of sessions to

00:15:14.375 --> 00:15:18.650
keep take into consideration. So another thing we

00:15:18.650 --> 00:15:22.330
have are tokens. Right? So tokens are able

00:15:22.330 --> 00:15:24.410
to solve this problem of scalability that we

00:15:24.410 --> 00:15:27.690
previously saw with sessions. The way that tokens

00:15:27.690 --> 00:15:29.530
work is that a user is going to

00:15:29.530 --> 00:15:31.865
submit their login form. So they're sending the

00:15:31.865 --> 00:15:34.105
post request to the server, pinging the API

00:15:34.105 --> 00:15:38.505
login endpoint. And the server is going to

00:15:38.505 --> 00:15:41.465
take in the user's credentials and create a

00:15:41.465 --> 00:15:44.985
unique JSON web token object for the client.

00:15:48.590 --> 00:15:50.510
Now the client is going to put this

00:15:50.510 --> 00:15:56.430
token in their local storage. And upon make

00:15:56.510 --> 00:15:59.630
or sorry. In making future requests, the client

00:15:59.630 --> 00:16:01.790
is going to send this token back to

00:16:01.790 --> 00:16:05.445
the server with the signed header that is

00:16:05.445 --> 00:16:07.445
going to get decrypted by the server and

00:16:07.445 --> 00:16:10.965
validated upon future requests. So the token actually

00:16:10.965 --> 00:16:14.245
carries the user's credentials, but very securely because

00:16:14.245 --> 00:16:16.280
you can't spoof a token. So it's going

00:16:16.280 --> 00:16:18.760
to carry the user's credentials, and the server

00:16:18.760 --> 00:16:20.200
is going to be able to decrypt this

00:16:20.200 --> 00:16:23.000
token and use it to basically give the

00:16:23.000 --> 00:16:25.000
user all of its information that it should

00:16:25.000 --> 00:16:29.515
have access to. And so let's contrast this

00:16:29.515 --> 00:16:31.435
with sessions. Right? So remember sessions, we had

00:16:31.435 --> 00:16:33.515
this global lookup table. It stores all the

00:16:33.515 --> 00:16:36.075
user information on the server side. And with

00:16:36.075 --> 00:16:39.435
tokens, instead, the user information or sorry, the

00:16:39.435 --> 00:16:42.330
user credentials are stored in this token object,

00:16:42.410 --> 00:16:45.210
but this token object is encrypted very securely.

00:16:45.210 --> 00:16:47.850
And so the server is decrypting this token

00:16:47.930 --> 00:16:50.250
using the token's header that gets sent back

00:16:50.250 --> 00:16:56.515
when the client makes future requests. So turn

00:16:56.515 --> 00:16:58.435
and talk to your neighbor again. Why do

00:16:58.435 --> 00:17:00.435
you think tokens solve the problem of verifying

00:17:00.435 --> 00:17:02.755
that we're logged in securely upon making future

00:17:02.755 --> 00:17:04.675
requests? How is this different than the dilemmas

00:17:04.675 --> 00:17:06.515
we described before? How is it different than

00:17:06.515 --> 00:17:08.620
sessions? I'll give you guys, like, thirty seconds

00:17:08.620 --> 00:18:14.330
to talk about it. Okay. So hopefully you

00:18:14.330 --> 00:18:16.090
guys had some time to discuss it once

00:18:16.090 --> 00:18:19.370
again. Now, would anyone like to, I don't

00:18:19.370 --> 00:18:28.115
know, offer an answer? Okay. It's okay. But

00:18:28.115 --> 00:18:30.515
basically, token solve the problem for us because

00:18:30.515 --> 00:18:33.155
tokens can't be spoofed. So I mentioned this

00:18:33.155 --> 00:18:35.235
before, right? We can spoof our IP addresses,

00:18:35.235 --> 00:18:37.315
we can very easily change or delete our

00:18:37.315 --> 00:18:40.030
URL query parameters, but tokens cannot be spoofed

00:18:40.030 --> 00:18:42.910
because they are, like, these securely created JSON

00:18:42.910 --> 00:18:46.270
objects that then send back the signature that

00:18:46.270 --> 00:18:48.350
gets decrypted by the server. So only the

00:18:48.350 --> 00:18:50.830
server can decrypt the tokens for us. And

00:18:50.475 --> 00:18:52.795
a user cannot forge a token, which is

00:18:52.795 --> 00:18:54.875
why we're not really trusting the client even

00:18:54.875 --> 00:18:56.395
though it might seem like the client is

00:18:56.395 --> 00:18:58.395
sending the token back. We're not trusting the

00:18:58.395 --> 00:19:01.755
client because the client cannot forge this token.

00:19:01.755 --> 00:19:04.155
This token was securely generated by the server,

00:19:04.155 --> 00:19:05.755
and the client is simply sending it back.

00:19:06.390 --> 00:19:08.390
Let's do a quick review of the difference

00:19:08.390 --> 00:19:11.350
between sessions and tokens. So with sessions, the

00:19:11.350 --> 00:19:14.390
authentication details are stored on the server side.

00:19:14.550 --> 00:19:16.950
With tokens, the user itself is storing their

00:19:16.950 --> 00:19:19.510
authentication details in the form of the token

00:19:19.510 --> 00:19:23.495
itself. When making future requests, the user is

00:19:23.495 --> 00:19:25.575
going to send back a cookie with sessions

00:19:25.575 --> 00:19:28.135
to have the request authorized. But with tokens,

00:19:28.135 --> 00:19:30.775
the user sends back the token itself. And

00:19:30.775 --> 00:19:32.375
what the server does in the case of

00:19:32.375 --> 00:19:34.375
sessions is it's going to go to its

00:19:34.375 --> 00:19:37.530
database and find the session thanks to the

00:19:37.530 --> 00:19:39.370
ID that was sent with the cookie. And

00:19:39.370 --> 00:19:41.050
once it finds the session in the global

00:19:41.050 --> 00:19:42.970
lookup table, it can send back all of

00:19:42.970 --> 00:19:45.370
the user information and verify that the user

00:19:45.370 --> 00:19:49.370
credentials are correct. With tokens, the server is

00:19:49.370 --> 00:19:51.805
going to decrypt the token, verify its signature,

00:19:51.805 --> 00:19:54.125
and check that this is like an actual

00:19:54.125 --> 00:19:56.285
valid token that was generated by the server

00:19:56.285 --> 00:20:00.925
previously. So let's pose a question. Do you

00:20:00.925 --> 00:20:03.165
guys think that the server can perform security

00:20:03.165 --> 00:20:05.460
actions in the case of sessions? Thumbs up

00:20:05.460 --> 00:20:13.380
for yes, thumbs down for no. I think

00:20:13.380 --> 00:20:16.820
like thumbs down, thumbs kind of like a

00:20:16.820 --> 00:20:19.335
mix. But for sessions, the answer is actually

00:20:19.335 --> 00:20:22.295
yes because all of the authentication details are

00:20:22.295 --> 00:20:24.215
stored on the server side. Right? So this

00:20:24.215 --> 00:20:26.135
means the server can actually perform all of

00:20:26.135 --> 00:20:28.135
the security actions it needs to because all

00:20:28.135 --> 00:20:30.535
of the details are stored on the server

00:20:30.535 --> 00:20:32.780
side. How about for tokens? Do you guys

00:20:32.780 --> 00:20:34.860
think thumbs up, the server can perform security

00:20:34.860 --> 00:20:40.460
actions, thumbs down for no? Yeah, exactly. Thumbs

00:20:40.460 --> 00:20:43.420
down, right? Because this time, the authentication details

00:20:43.420 --> 00:20:46.060
are stored on the user side. So the

00:20:45.165 --> 00:20:47.645
server doesn't actually have access to the or

00:20:47.645 --> 00:20:49.405
sorry, not access, but the server is not

00:20:49.405 --> 00:20:51.885
storing the authentication details. So on the server

00:20:51.885 --> 00:20:54.605
side, we can't really perform much security actions

00:20:54.605 --> 00:20:57.005
because the user is storing their details themselves.

00:20:58.770 --> 00:21:03.090
One thing to note though is that actually,

00:21:03.090 --> 00:21:06.530
it's fine. Okay. Does anyone have any questions?

00:21:08.690 --> 00:21:10.450
I'm pause here to give you guys some

00:21:10.450 --> 00:21:12.930
time to process what we just talked about.

00:21:18.345 --> 00:21:21.545
Okay. So now let's talk about Catbook. How

00:21:21.545 --> 00:21:23.785
are we incorporating all of this information that

00:21:23.785 --> 00:21:28.250
we just learned into Catbook? So Catbook's way

00:21:28.250 --> 00:21:29.770
of managing login is what we're going to

00:21:29.770 --> 00:21:31.290
do is we're going to have a separate

00:21:31.290 --> 00:21:34.250
auth server and a resource server. We talked

00:21:34.250 --> 00:21:36.410
about before how storing passwords is like really

00:21:36.410 --> 00:21:38.410
difficult, so we're just going to let Google

00:21:38.410 --> 00:21:39.955
do it for us. They're going handle all

00:21:39.955 --> 00:21:42.355
the authentication details and we're hopefully not going

00:21:42.355 --> 00:21:44.275
to have to deal with it. So when

00:21:44.275 --> 00:21:46.595
users initially sign in to Catbook, what they're

00:21:46.595 --> 00:21:48.035
going to do is they're going to sign

00:21:48.035 --> 00:21:50.275
in using Google. And what Google is going

00:21:50.275 --> 00:21:51.795
to do is Google is going to generate

00:21:51.795 --> 00:21:53.690
a token for the user and be like,

00:21:53.690 --> 00:21:55.930
hey, here's your token. The user is going

00:21:55.930 --> 00:21:57.850
to take this token and send it to

00:21:57.850 --> 00:22:00.090
the server. The server is going to verify

00:22:00.090 --> 00:22:02.250
this token. And then in order for the

00:22:02.250 --> 00:22:04.250
user to stay logged in, the server is

00:22:04.250 --> 00:22:07.225
going to generate sessions for the user. So

00:22:07.225 --> 00:22:09.465
remember we talked about with sessions and tokens,

00:22:09.465 --> 00:22:11.705
sessions scalability is kind of hard because we're

00:22:11.705 --> 00:22:14.025
storing all of these global lookup tables, so

00:22:14.025 --> 00:22:16.345
if we have multiple servers, it's difficult. Luckily,

00:22:16.345 --> 00:22:18.025
we only have one server, so our server

00:22:18.025 --> 00:22:20.790
can use these sessions to manage login and

00:22:20.790 --> 00:22:24.470
persist login information. Tokens don't have the issue

00:22:24.470 --> 00:22:26.390
of scalability, so even though Google has like

00:22:26.390 --> 00:22:28.470
millions of these millions of users in this

00:22:28.470 --> 00:22:31.270
super large platform, these tokens make it really

00:22:31.270 --> 00:22:33.430
easy because the server itself doesn't have to

00:22:33.430 --> 00:22:37.355
store the user's information. So here's our sign

00:22:37.355 --> 00:22:40.155
in flow proposal. Right? So I'm going to

00:22:40.155 --> 00:22:44.075
sign in to the Google auth server, and

00:22:44.075 --> 00:22:45.755
let's say it was a success. Now I'm

00:22:45.755 --> 00:22:47.115
going to tell my server that I logged

00:22:47.115 --> 00:22:48.395
in, and the server is going to check

00:22:48.395 --> 00:22:50.635
the user database to see if I'm actually

00:22:50.635 --> 00:22:54.550
a user. But let's say, like, I type

00:22:54.550 --> 00:22:57.110
in the wrong password. Right? I could still

00:22:57.110 --> 00:22:59.830
theoretically tell the server that I've already successfully

00:22:59.830 --> 00:23:03.590
authenticated with Google. And then there's nothing stopping

00:23:03.590 --> 00:23:05.830
me from, like, as a malicious hacker, just

00:23:05.830 --> 00:23:08.735
saying that I already successfully authenticated with Google.

00:23:09.615 --> 00:23:10.895
Right? So this goes back to a point

00:23:10.895 --> 00:23:13.695
of like never trusting the client because the

00:23:13.695 --> 00:23:16.495
front end can very easily be modified. So

00:23:16.495 --> 00:23:18.175
that's why we're gonna use the tokens. Right?

00:23:18.175 --> 00:23:20.390
So Google is going to generate a token

00:23:20.390 --> 00:23:23.350
for us, which remember, tokens are securely generated,

00:23:23.350 --> 00:23:26.230
cannot be spoofed by the user. So now,

00:23:26.230 --> 00:23:27.990
we take this token and we give our

00:23:27.990 --> 00:23:30.550
token to the server and say, yeah, I

00:23:30.550 --> 00:23:32.825
did actually log in with Google and my

00:23:32.825 --> 00:23:35.065
token is proof that I've successfully authenticated with

00:23:35.065 --> 00:23:37.705
Google because I can't, like, forge this token.

00:23:39.465 --> 00:23:41.065
So now the server is going to make

00:23:41.065 --> 00:23:43.065
sure this is a legit token by checking

00:23:43.065 --> 00:23:44.905
in the Google auth library that it was

00:23:44.905 --> 00:23:48.070
very conveniently set up for us. And then

00:23:48.070 --> 00:23:50.390
once it verifies that it's a legit token,

00:23:50.390 --> 00:23:53.830
it's going to check the user database. It's

00:23:53.830 --> 00:23:55.110
not going to work if you're a hacker

00:23:55.110 --> 00:23:56.470
because the hacker is not going to get

00:23:56.470 --> 00:23:58.790
a token. So this sign in flow is

00:23:58.790 --> 00:24:00.955
not going to work. Even if you, like,

00:24:00.955 --> 00:24:02.635
spoof a token, the server is going to

00:24:02.635 --> 00:24:04.635
check-in the Google auth library and see that

00:24:04.635 --> 00:24:07.115
this is a forged token, so you're not

00:24:07.115 --> 00:24:10.075
gonna be able to get your information. Okay.

00:24:10.075 --> 00:24:12.955
So now let's demo this. You guys can

00:24:12.955 --> 00:24:14.315
also take, like, a two minute break while

00:24:14.315 --> 00:25:31.585
we get set up. Okay. So now let's

00:25:31.585 --> 00:25:34.145
take a quick look at how we can

00:25:34.145 --> 00:25:36.785
actually see our tokens and cookies being sent.

00:25:37.585 --> 00:25:40.890
So let's navigate to Catbook. If you guys

00:25:40.890 --> 00:25:45.370
want to follow along, can go to get

00:25:45.370 --> 00:25:49.290
checkout w five complete. And basically, what I'm

00:25:49.290 --> 00:25:50.970
going to do is I'm going to log

00:25:50.970 --> 00:25:52.650
in to Google. So now we have like

00:25:52.650 --> 00:25:54.570
this sign in option. Right? So I'm gonna

00:25:54.570 --> 00:26:05.985
log in. I'll log in as myself. And

00:26:05.985 --> 00:26:07.665
we'll see that once I've logged in, right,

00:26:09.220 --> 00:26:11.540
I should be able to go to inspect.

00:26:14.900 --> 00:26:20.020
And I can go to network tab. Let's

00:26:20.020 --> 00:26:37.890
refresh. Let's sign out. Sign in again. We

00:26:37.890 --> 00:26:42.290
should see this login if we go to

00:26:42.290 --> 00:26:44.050
our network tab. Right? And so this is

00:26:44.050 --> 00:26:47.330
us ping the login endpoint on our Catbook

00:26:47.330 --> 00:26:50.705
server. And if we go to the if

00:26:50.705 --> 00:26:52.225
we click on the request, right, we can

00:26:52.225 --> 00:26:54.625
see, like, the request URL is being sent

00:26:54.625 --> 00:26:57.105
to our API login endpoint is a post

00:26:57.105 --> 00:27:01.460
request. And we can also see that if

00:27:01.460 --> 00:27:03.380
we go to the payload, we have our

00:27:03.380 --> 00:27:05.940
token here. So this is the token that

00:27:05.940 --> 00:27:09.300
Google is actually giving to us upon authorizing

00:27:09.300 --> 00:27:11.780
with the Google auth library. And so what

00:27:11.780 --> 00:27:13.460
we can do is we can actually take

00:27:13.460 --> 00:27:16.365
this token. It's pretty cool because you can

00:27:16.365 --> 00:27:17.805
take this token and you can go to

00:27:17.805 --> 00:27:23.165
this website called jwt.io. And you can actually

00:27:23.165 --> 00:27:25.085
try and follow along and paste the token

00:27:25.085 --> 00:27:28.365
that you get into jwt..io. And you can

00:27:28.365 --> 00:27:30.970
see that we have our encoded token here.

00:27:30.970 --> 00:27:33.290
And once we decode it, we actually have

00:27:33.290 --> 00:27:35.690
a lot of information that is stored in

00:27:35.690 --> 00:27:37.690
this token. So we can see things like

00:27:37.690 --> 00:27:42.250
my email address, my name, and also like

00:27:41.685 --> 00:27:43.845
all the other user credentials that are actually

00:27:43.845 --> 00:27:46.965
being stored within this token. But the header

00:27:46.965 --> 00:27:48.645
and the payload of this token are not

00:27:48.645 --> 00:27:51.365
actually secure. It's just like base 64 encoded,

00:27:51.365 --> 00:27:54.405
so it's very easily decryptable. But what actually

00:27:54.405 --> 00:27:56.325
makes it secure is the signature part of

00:27:56.325 --> 00:28:00.200
the token, which I've, like, deleted just for,

00:28:00.200 --> 00:28:03.640
like, security purposes. But, basically, the signature is

00:28:03.640 --> 00:28:08.840
what actually makes a token secure. So, yeah,

00:28:08.840 --> 00:28:10.920
you guys can see, like, if you check

00:28:10.920 --> 00:28:13.845
the login post request and you go to

00:28:13.845 --> 00:28:15.445
the request payload, you should be able to

00:28:15.445 --> 00:28:17.685
see the token that Google is sending to

00:28:17.685 --> 00:28:19.365
you to the client to prove that they

00:28:19.365 --> 00:28:23.285
have logged in. Okay. So now let's talk

00:28:23.285 --> 00:28:25.845
about our cookies. So we got our token.

00:28:25.845 --> 00:28:27.685
Right? So if we go back to Catbook,

00:28:28.460 --> 00:28:30.540
now let's take a look at our cookies.

00:28:30.540 --> 00:28:32.540
You can go to the cookies tab, and

00:28:32.540 --> 00:28:35.020
we notice that we have like this connect

00:28:35.020 --> 00:28:37.660
dot sid cookie, which is also shown like

00:28:37.660 --> 00:28:39.340
if we go to the headers of the

00:28:39.340 --> 00:28:42.835
login request, we should also see like we

00:28:42.835 --> 00:28:45.155
have this cookie right right here where it

00:28:45.155 --> 00:28:49.475
starts with, like, g enabled. And so this

00:28:49.475 --> 00:28:52.595
cookie is actually enabling us to stay logged

00:28:52.595 --> 00:28:55.155
in. So once we've pinged the login endpoint

00:28:55.700 --> 00:28:58.020
and Google has given us a token, we

00:28:58.020 --> 00:28:59.700
then take that token, give it to the

00:28:59.700 --> 00:29:01.700
server, and the server will generate this cookie

00:29:01.700 --> 00:29:03.700
for us to ensure that we can stay

00:29:03.700 --> 00:29:05.540
logged in even if I refresh the page.

00:29:05.540 --> 00:29:06.740
So you see that, like, even if I

00:29:06.740 --> 00:29:08.740
refresh Catbook, right, I'm still logged in. Like,

00:29:08.740 --> 00:29:10.975
the sign out button is still there, which

00:29:10.975 --> 00:29:13.935
means I haven't been signed out. And what

00:29:13.935 --> 00:29:17.055
we can try is oops. We can try

00:29:17.055 --> 00:29:18.815
it to look at is, let's say we,

00:29:18.815 --> 00:29:23.930
like, go back to the cookie. Let me

00:29:23.930 --> 00:29:31.690
log in again. Let's go back to it

00:29:31.690 --> 00:29:36.010
and let's like try like going to our

00:29:36.010 --> 00:29:45.735
headers. Looks like application. And let's like delete

00:29:45.735 --> 00:29:47.255
the cookie. Okay? So I'm just gonna like

00:29:47.255 --> 00:29:51.670
manually delete this cookie. And you should notice

00:29:51.670 --> 00:29:55.030
now that if I refresh, I'll automatically be

00:29:55.030 --> 00:29:58.310
signed out. So if you delete the cookie

00:29:58.310 --> 00:30:00.470
just like manually, you're no longer going to

00:30:00.470 --> 00:30:02.790
be signed into Catbook, right, because you're no

00:30:02.790 --> 00:30:04.675
longer going to be able to send requests

00:30:04.675 --> 00:30:06.595
back with the cookie to the server to

00:30:06.595 --> 00:30:08.675
prove that you've already logged in. So this

00:30:08.675 --> 00:30:10.435
is how our Catbook server is able to

00:30:10.435 --> 00:30:16.250
manage users and persist their sessions. Yeah. So

00:30:16.250 --> 00:30:17.610
it's kind of talked about how if we

00:30:17.610 --> 00:30:19.770
manually delete the cookie, we automatically get logged

00:30:19.770 --> 00:30:24.170
out. And remember that when we make future

00:30:24.170 --> 00:30:26.650
requests and we ping like other endpoints, we

00:30:26.650 --> 00:30:29.130
are actually sending the cookie back as identity

00:30:29.130 --> 00:30:31.865
verification. So we can see that, like, if

00:30:31.865 --> 00:30:36.105
I just, like, sign in again. I should

00:30:36.105 --> 00:30:37.625
be able to see, like, in my network

00:30:37.625 --> 00:30:39.465
tab that I have, like, other requests. Right?

00:30:39.465 --> 00:30:42.105
So I'm, like, making other requests. So I

00:30:42.105 --> 00:30:56.780
should have, like, Like when I make comment

00:30:56.780 --> 00:30:58.860
requests, you can notice that I'm like sending

00:30:58.860 --> 00:31:02.700
the cookie in the request each time I

00:31:02.175 --> 00:31:07.135
make a get request to our server. Okay.

00:31:07.135 --> 00:31:08.975
So that was kind of like a lot

00:31:08.975 --> 00:31:11.535
of information. So let's recap really quickly before

00:31:11.535 --> 00:31:14.340
we dive into the workshop. Let's talk about

00:31:14.340 --> 00:31:17.780
the difference between authentication and authorization. So authentication

00:31:17.780 --> 00:31:19.860
is a process of use verifying our users

00:31:19.860 --> 00:31:23.380
credentials. So this is like, if Sophie is

00:31:23.380 --> 00:31:26.020
visiting my house, authentication would be like me

00:31:26.020 --> 00:31:28.820
saying, Sophie, I recognize Sophie and Sophie can't

00:31:28.820 --> 00:31:31.995
enter my house. Authorization is a process of

00:31:31.995 --> 00:31:35.355
actually verifying the user's permissions and rendering different

00:31:35.355 --> 00:31:38.315
things conditionally depending on what permissions that user

00:31:38.315 --> 00:31:40.475
might have. So if Sophie comes over to

00:31:40.475 --> 00:31:42.460
my house, like, yes, I recognize her, but

00:31:42.460 --> 00:31:44.140
do I give her the permission or the

00:31:44.140 --> 00:31:46.700
authorization to enter my bathroom or, like, enter

00:31:46.700 --> 00:31:50.380
certain rooms inside of my house? We saw

00:31:50.380 --> 00:31:52.140
that it's really hard to trust the client.

00:31:52.140 --> 00:31:54.140
We can't trust things that the user is

00:31:54.140 --> 00:31:56.905
saying because URL query parameters, you can like

00:31:56.905 --> 00:31:59.305
delete these, change these IP addresses, you can

00:31:59.305 --> 00:32:02.345
spoof them. So we need to use something

00:32:02.345 --> 00:32:04.185
that's a little bit more secure. So we're

00:32:04.185 --> 00:32:06.825
going to use sessions and tokens. So for

00:32:06.825 --> 00:32:09.305
us, what happens is Google Auth is taking

00:32:09.305 --> 00:32:12.230
in the user's credentials, it's generating this secure

00:32:12.230 --> 00:32:14.550
token and sending it back to the client.

00:32:14.710 --> 00:32:16.950
And this token is verified via the privately

00:32:16.950 --> 00:32:21.270
generated signature that we saw. And then what's

00:32:21.270 --> 00:32:23.430
happening is now the user has this token.

00:32:23.510 --> 00:32:25.055
They can make a request to the login

00:32:25.055 --> 00:32:27.215
API endpoint in r server dot j s

00:32:27.215 --> 00:32:30.015
file of Catbook. The server can check if

00:32:30.015 --> 00:32:32.175
the token is valid by checking in the

00:32:32.175 --> 00:32:35.375
Google auth library. And if it is, then

00:32:35.375 --> 00:32:38.200
the server can go check MongoDB or it

00:32:38.200 --> 00:32:41.240
can store the user's information within MongoDB. And

00:32:41.240 --> 00:32:42.760
this is like the cookie that we saw

00:32:42.760 --> 00:32:45.000
here, where if we deleted it, the user

00:32:45.000 --> 00:32:48.120
is no longer logged in. Now the user

00:32:48.120 --> 00:32:50.200
is going to send the cookie back that

00:32:50.200 --> 00:32:53.175
was generated by the server with its unique

00:32:53.175 --> 00:32:55.895
ID on subsequent requests to prove that the

00:32:55.895 --> 00:32:58.775
user has already been authenticated. And then now,

00:32:58.775 --> 00:33:01.895
the server will give authorization and, like, display

00:33:01.895 --> 00:33:05.400
your, like, cat book stories and comments. And

00:33:05.400 --> 00:33:06.840
as we're going to see tomorrow in the

00:33:06.840 --> 00:33:11.800
sockets lecture, real time messages also. Does anyone

00:33:11.800 --> 00:33:20.026
have any questions? Okay. Cool. That was all

00:33:20.026 --> 00:33:22.186
for the intro to auth. Now Sophie is

00:33:22.186 --> 00:33:24.026
going to take you to the very meaty

00:33:24.026 --> 00:33:24.586
workshop.
